{"version":3,"sources":["../node_modules/spdx-expression-parse/scan.js"],"names":["licenses","require","exceptions","module","index","source","value","chars","match","read","possibilities","i","string","type","idstring","expectIdstring","begin","operator","documentRef","licenseRef","identifier","tokens","hasMore","skipWhitespace","token","parseToken"],"mappings":"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","sourcesContent":["'use strict'\n\nvar licenses = []\n  .concat(require('spdx-license-ids'))\n  .concat(require('spdx-license-ids/deprecated'))\nvar exceptions = require('spdx-exceptions')\n\nmodule.exports = function (source) {\n  var index = 0\n\n  function hasMore () {\n    return index < source.length\n  }\n\n  // `value` can be a regexp or a string.\n  // If it is recognized, the matching source string is returned and\n  // the index is incremented. Otherwise `undefined` is returned.\n  function read (value) {\n    if (value instanceof RegExp) {\n      var chars = source.slice(index)\n      var match = chars.match(value)\n      if (match) {\n        index += match[0].length\n        return match[0]\n      }\n    } else {\n      if (source.indexOf(value, index) === index) {\n        index += value.length\n        return value\n      }\n    }\n  }\n\n  function skipWhitespace () {\n    read(/[ ]*/)\n  }\n\n  function operator () {\n    var string\n    var possibilities = ['WITH', 'AND', 'OR', '(', ')', ':', '+']\n    for (var i = 0; i < possibilities.length; i++) {\n      string = read(possibilities[i])\n      if (string) {\n        break\n      }\n    }\n\n    if (string === '+' && index > 1 && source[index - 2] === ' ') {\n      throw new Error('Space before `+`')\n    }\n\n    return string && {\n      type: 'OPERATOR',\n      string: string\n    }\n  }\n\n  function idstring () {\n    return read(/[A-Za-z0-9-.]+/)\n  }\n\n  function expectIdstring () {\n    var string = idstring()\n    if (!string) {\n      throw new Error('Expected idstring at offset ' + index)\n    }\n    return string\n  }\n\n  function documentRef () {\n    if (read('DocumentRef-')) {\n      var string = expectIdstring()\n      return {type: 'DOCUMENTREF', string: string}\n    }\n  }\n\n  function licenseRef () {\n    if (read('LicenseRef-')) {\n      var string = expectIdstring()\n      return {type: 'LICENSEREF', string: string}\n    }\n  }\n\n  function identifier () {\n    var begin = index\n    var string = idstring()\n\n    if (licenses.indexOf(string) !== -1) {\n      return {\n        type: 'LICENSE',\n        string: string\n      }\n    } else if (exceptions.indexOf(string) !== -1) {\n      return {\n        type: 'EXCEPTION',\n        string: string\n      }\n    }\n\n    index = begin\n  }\n\n  // Tries to read the next token. Returns `undefined` if no token is\n  // recognized.\n  function parseToken () {\n    // Ordering matters\n    return (\n      operator() ||\n      documentRef() ||\n      licenseRef() ||\n      identifier()\n    )\n  }\n\n  var tokens = []\n  while (hasMore()) {\n    skipWhitespace()\n    if (!hasMore()) {\n      break\n    }\n\n    var token = parseToken()\n    if (!token) {\n      throw new Error('Unexpected `' + source[index] +\n                      '` at offset ' + index)\n    }\n\n    tokens.push(token)\n  }\n  return tokens\n}\n"],"file":"scan.js"}