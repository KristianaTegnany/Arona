{"version":3,"sources":["../node_modules/punycode/punycode.js"],"names":["maxInt","base","tMin","tMax","skew","damp","initialBias","initialN","delimiter","regexPunycode","regexNonASCII","regexSeparators","errors","baseMinusTMin","floor","Math","stringFromCharCode","String","result","length","array","fn","parts","string","labels","encoded","map","output","counter","value","extra","ucs2encode","basicToDigit","codePoint","digitToBasic","digit","flag","adapt","k","delta","firstTime","decode","inputLength","input","i","n","bias","basic","j","error","index","oldi","w","t","baseMinusT","out","encode","ucs2decode","currentValue","basicLength","handledCPCount","m","handledCPCountPlusOne","q","qMinusT","toUnicode","mapDomain","toASCII","punycode","module"],"mappings":"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","sourcesContent":["'use strict';\n\n/** Highest positive signed 32-bit float value */\nconst maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n/** Bootstring parameters */\nconst base = 36;\nconst tMin = 1;\nconst tMax = 26;\nconst skew = 38;\nconst damp = 700;\nconst initialBias = 72;\nconst initialN = 128; // 0x80\nconst delimiter = '-'; // '\\x2D'\n\n/** Regular expressions */\nconst regexPunycode = /^xn--/;\nconst regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\nconst regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n/** Error messages */\nconst errors = {\n\t'overflow': 'Overflow: input needs wider integers to process',\n\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t'invalid-input': 'Invalid input'\n};\n\n/** Convenience shortcuts */\nconst baseMinusTMin = base - tMin;\nconst floor = Math.floor;\nconst stringFromCharCode = String.fromCharCode;\n\n/*--------------------------------------------------------------------------*/\n\n/**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */\nfunction error(type) {\n\tthrow new RangeError(errors[type]);\n}\n\n/**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */\nfunction map(array, fn) {\n\tconst result = [];\n\tlet length = array.length;\n\twhile (length--) {\n\t\tresult[length] = fn(array[length]);\n\t}\n\treturn result;\n}\n\n/**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {Array} A new string of characters returned by the callback\n * function.\n */\nfunction mapDomain(string, fn) {\n\tconst parts = string.split('@');\n\tlet result = '';\n\tif (parts.length > 1) {\n\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t// the local part (i.e. everything up to `@`) intact.\n\t\tresult = parts[0] + '@';\n\t\tstring = parts[1];\n\t}\n\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\tstring = string.replace(regexSeparators, '\\x2E');\n\tconst labels = string.split('.');\n\tconst encoded = map(labels, fn).join('.');\n\treturn result + encoded;\n}\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nfunction ucs2decode(string) {\n\tconst output = [];\n\tlet counter = 0;\n\tconst length = string.length;\n\twhile (counter < length) {\n\t\tconst value = string.charCodeAt(counter++);\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t// It's a high surrogate, and there is a next character.\n\t\t\tconst extra = string.charCodeAt(counter++);\n\t\t\tif ((extra & 0xFC00) == 0xDC00) { // Low surrogate.\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t} else {\n\t\t\t\t// It's an unmatched surrogate; only append this code unit, in case the\n\t\t\t\t// next code unit is the high surrogate of a surrogate pair.\n\t\t\t\toutput.push(value);\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t} else {\n\t\t\toutput.push(value);\n\t\t}\n\t}\n\treturn output;\n}\n\n/**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */\nconst ucs2encode = array => String.fromCodePoint(...array);\n\n/**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */\nconst basicToDigit = function(codePoint) {\n\tif (codePoint - 0x30 < 0x0A) {\n\t\treturn codePoint - 0x16;\n\t}\n\tif (codePoint - 0x41 < 0x1A) {\n\t\treturn codePoint - 0x41;\n\t}\n\tif (codePoint - 0x61 < 0x1A) {\n\t\treturn codePoint - 0x61;\n\t}\n\treturn base;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */\nconst digitToBasic = function(digit, flag) {\n\t//  0..25 map to ASCII a..z or A..Z\n\t// 26..35 map to ASCII 0..9\n\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */\nconst adapt = function(delta, numPoints, firstTime) {\n\tlet k = 0;\n\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\tdelta += floor(delta / numPoints);\n\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\tdelta = floor(delta / baseMinusTMin);\n\t}\n\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */\nconst decode = function(input) {\n\t// Don't use UCS-2.\n\tconst output = [];\n\tconst inputLength = input.length;\n\tlet i = 0;\n\tlet n = initialN;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points: let `basic` be the number of input code\n\t// points before the last delimiter, or `0` if there is none, then copy\n\t// the first basic code points to the output.\n\n\tlet basic = input.lastIndexOf(delimiter);\n\tif (basic < 0) {\n\t\tbasic = 0;\n\t}\n\n\tfor (let j = 0; j < basic; ++j) {\n\t\t// if it's not a basic code point\n\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\terror('not-basic');\n\t\t}\n\t\toutput.push(input.charCodeAt(j));\n\t}\n\n\t// Main decoding loop: start just after the last delimiter if any basic code\n\t// points were copied; start at the beginning otherwise.\n\n\tfor (let index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t// `index` is the index of the next character to be consumed.\n\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t// which gets added to `i`. The overflow checking is easier\n\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t// value at the end to obtain `delta`.\n\t\tlet oldi = i;\n\t\tfor (let w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\tif (index >= inputLength) {\n\t\t\t\terror('invalid-input');\n\t\t\t}\n\n\t\t\tconst digit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\ti += digit * w;\n\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\tif (digit < t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst baseMinusT = base - t;\n\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tw *= baseMinusT;\n\n\t\t}\n\n\t\tconst out = output.length + 1;\n\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t// incrementing `n` each time, so we'll fix that now:\n\t\tif (floor(i / out) > maxInt - n) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tn += floor(i / out);\n\t\ti %= out;\n\n\t\t// Insert `n` at position `i` of the output.\n\t\toutput.splice(i++, 0, n);\n\n\t}\n\n\treturn String.fromCodePoint(...output);\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */\nconst encode = function(input) {\n\tconst output = [];\n\n\t// Convert the input in UCS-2 to an array of Unicode code points.\n\tinput = ucs2decode(input);\n\n\t// Cache the length.\n\tlet inputLength = input.length;\n\n\t// Initialize the state.\n\tlet n = initialN;\n\tlet delta = 0;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points.\n\tfor (const currentValue of input) {\n\t\tif (currentValue < 0x80) {\n\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t}\n\t}\n\n\tlet basicLength = output.length;\n\tlet handledCPCount = basicLength;\n\n\t// `handledCPCount` is the number of code points that have been handled;\n\t// `basicLength` is the number of basic code points.\n\n\t// Finish the basic string with a delimiter unless it's empty.\n\tif (basicLength) {\n\t\toutput.push(delimiter);\n\t}\n\n\t// Main encoding loop:\n\twhile (handledCPCount < inputLength) {\n\n\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t// larger one:\n\t\tlet m = maxInt;\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\tm = currentValue;\n\t\t\t}\n\t\t}\n\n\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t// but guard against overflow.\n\t\tconst handledCPCountPlusOne = handledCPCount + 1;\n\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\tn = m;\n\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\t\t\tif (currentValue == n) {\n\t\t\t\t// Represent delta as a generalized variable-length integer.\n\t\t\t\tlet q = delta;\n\t\t\t\tfor (let k = base; /* no condition */; k += base) {\n\t\t\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tconst qMinusT = q - t;\n\t\t\t\t\tconst baseMinusT = base - t;\n\t\t\t\t\toutput.push(\n\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t);\n\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t}\n\n\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\tdelta = 0;\n\t\t\t\t++handledCPCount;\n\t\t\t}\n\t\t}\n\n\t\t++delta;\n\t\t++n;\n\n\t}\n\treturn output.join('');\n};\n\n/**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */\nconst toUnicode = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexPunycode.test(string)\n\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t: string;\n\t});\n};\n\n/**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */\nconst toASCII = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexNonASCII.test(string)\n\t\t\t? 'xn--' + encode(string)\n\t\t\t: string;\n\t});\n};\n\n/*--------------------------------------------------------------------------*/\n\n/** Define the public API */\nconst punycode = {\n\t/**\n\t * A string representing the current Punycode.js version number.\n\t * @memberOf punycode\n\t * @type String\n\t */\n\t'version': '2.1.0',\n\t/**\n\t * An object of methods to convert from JavaScript's internal character\n\t * representation (UCS-2) to Unicode code points, and back.\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode\n\t * @type Object\n\t */\n\t'ucs2': {\n\t\t'decode': ucs2decode,\n\t\t'encode': ucs2encode\n\t},\n\t'decode': decode,\n\t'encode': encode,\n\t'toASCII': toASCII,\n\t'toUnicode': toUnicode\n};\n\nmodule.exports = punycode;\n"],"file":"punycode.js"}