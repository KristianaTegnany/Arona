{"version":3,"sources":["../node_modules/minimatch/minimatch.js"],"names":["module","minimatch","path","sep","require","GLOBSTAR","Minimatch","expand","plTypes","open","close","qmark","star","twoStarDot","twoStarNoDot","reSpecials","charSet","set","slashSplit","options","a","b","t","Object","orig","m","ext","pattern","p","console","s","negate","negateOffset","i","l","braceExpand","SUBPARSE","re","hasMagic","escaping","patternListStack","negativeLists","inClass","reClassStart","classStart","patternStart","self","stateChar","len","c","clearStateChar","type","start","reStart","pl","cs","RegExp","sp","tail","$2","$1","addPatternStart","n","nl","nlBefore","nlFirst","nlLast","nlAfter","openParensBefore","cleanAfter","dollar","isSub","newRe","globUnescape","flags","regExp","twoStar","regExpEscape","mm","list","f","filename","file","hit","fi","pi","fl","fr","pr","swallowee","emptyFileEnd"],"mappings":";;AAAAA,MAAM,CAANA,OAAAA,GAAAA,SAAAA;AACAC,SAAS,CAATA,SAAAA,GAAAA,SAAAA;AAEA,IAAIC,IAAI,GAAG;AAAEC,EAAAA,GAAG,EAAE;AAAP,CAAX;;AACA,IAAI;AACFD,EAAAA,IAAI,GAAGE,OAAO,CAAdF,MAAc,CAAdA;AADF,CAAA,CAEE,OAAA,EAAA,EAAW,CAAE;;AAEf,IAAIG,QAAQ,GAAGJ,SAAS,CAATA,QAAAA,GAAqBK,SAAS,CAATA,QAAAA,GAApC,EAAA;;AACA,IAAIC,MAAM,GAAGH,OAAO,CAApB,iBAAoB,CAApB;;AAEA,IAAII,OAAO,GAAG;AACZ,OAAK;AAAEC,IAAAA,IAAI,EAAN,WAAA;AAAqBC,IAAAA,KAAK,EAAE;AAA5B,GADO;AAEZ,OAAK;AAAED,IAAAA,IAAI,EAAN,KAAA;AAAeC,IAAAA,KAAK,EAAE;AAAtB,GAFO;AAGZ,OAAK;AAAED,IAAAA,IAAI,EAAN,KAAA;AAAeC,IAAAA,KAAK,EAAE;AAAtB,GAHO;AAIZ,OAAK;AAAED,IAAAA,IAAI,EAAN,KAAA;AAAeC,IAAAA,KAAK,EAAE;AAAtB,GAJO;AAKZ,OAAK;AAAED,IAAAA,IAAI,EAAN,KAAA;AAAeC,IAAAA,KAAK,EAAE;AAAtB;AALO,CAAd,C,CAQA;AACA;;AACA,IAAIC,KAAK,GAAT,MAAA,C,CAEA;;AACA,IAAIC,IAAI,GAAGD,KAAK,GAAhB,IAAA,C,CAEA;AACA;AACA;;AACA,IAAIE,UAAU,GAAd,2CAAA,C,CAEA;AACA;;AACA,IAAIC,YAAY,GAAhB,0BAAA,C,CAEA;;AACA,IAAIC,UAAU,GAAGC,OAAO,CAAxB,iBAAwB,CAAxB,C,CAEA;;AACA,SAAA,OAAA,CAAA,CAAA,EAAqB;AACnB,SAAO,CAAC,CAAD,KAAA,CAAA,EAAA,EAAA,MAAA,CAAmB,UAAA,GAAA,EAAA,CAAA,EAAkB;AAC1CC,IAAAA,GAAG,CAAHA,CAAG,CAAHA,GAAAA,IAAAA;AACA,WAAA,GAAA;AAFK,GAAA,EAAP,EAAO,CAAP;EAMF;;;AACA,IAAIC,UAAU,GAAd,KAAA;AAEAjB,SAAS,CAATA,MAAAA,GAAAA,MAAAA;;AACA,SAAA,MAAA,CAAA,OAAA,EAAA,OAAA,EAAmC;AACjCkB,EAAAA,OAAO,GAAGA,OAAO,IAAjBA,EAAAA;AACA,SAAO,UAAA,CAAA,EAAA,CAAA,EAAA,IAAA,EAAsB;AAC3B,WAAOlB,SAAS,CAAA,CAAA,EAAA,OAAA,EAAhB,OAAgB,CAAhB;AADF,GAAA;AAGD;;AAED,SAAA,GAAA,CAAA,CAAA,EAAA,CAAA,EAAoB;AAClBmB,EAAAA,CAAC,GAAGA,CAAC,IAALA,EAAAA;AACAC,EAAAA,CAAC,GAAGA,CAAC,IAALA,EAAAA;AACA,MAAIC,CAAC,GAAL,EAAA;AACAC,EAAAA,MAAM,CAANA,IAAAA,CAAAA,CAAAA,EAAAA,OAAAA,CAAuB,UAAA,CAAA,EAAa;AAClCD,IAAAA,CAAC,CAADA,CAAC,CAADA,GAAOD,CAAC,CAARC,CAAQ,CAARA;AADFC,GAAAA;AAGAA,EAAAA,MAAM,CAANA,IAAAA,CAAAA,CAAAA,EAAAA,OAAAA,CAAuB,UAAA,CAAA,EAAa;AAClCD,IAAAA,CAAC,CAADA,CAAC,CAADA,GAAOF,CAAC,CAARE,CAAQ,CAARA;AADFC,GAAAA;AAGA,SAAA,CAAA;AACD;;AAEDtB,SAAS,CAATA,QAAAA,GAAqB,UAAA,GAAA,EAAe;AAClC,MAAI,CAAA,GAAA,IAAQ,CAACsB,MAAM,CAANA,IAAAA,CAAAA,GAAAA,EAAb,MAAA,EAAsC,OAAA,SAAA;AAEtC,MAAIC,IAAI,GAAR,SAAA;;AAEA,MAAIC,CAAC,GAAG,SAAA,SAAA,CAAA,CAAA,EAAA,OAAA,EAAA,OAAA,EAAyC;AAC/C,WAAOD,IAAI,CAAJA,SAAAA,CAAAA,CAAAA,EAAAA,OAAAA,EAA2BE,GAAG,CAAA,GAAA,EAArC,OAAqC,CAA9BF,CAAP;AADF,GAAA;;AAIAC,EAAAA,CAAC,CAADA,SAAAA,GAAc,SAAA,SAAA,CAAA,OAAA,EAAA,OAAA,EAAsC;AAClD,WAAO,IAAID,IAAI,CAAR,SAAA,CAAA,OAAA,EAA4BE,GAAG,CAAA,GAAA,EAAtC,OAAsC,CAA/B,CAAP;AADFD,GAAAA;;AAIA,SAAA,CAAA;AAbFxB,CAAAA;;AAgBAK,SAAS,CAATA,QAAAA,GAAqB,UAAA,GAAA,EAAe;AAClC,MAAI,CAAA,GAAA,IAAQ,CAACiB,MAAM,CAANA,IAAAA,CAAAA,GAAAA,EAAb,MAAA,EAAsC,OAAA,SAAA;AACtC,SAAOtB,SAAS,CAATA,QAAAA,CAAAA,GAAAA,EAAP,SAAA;AAFFK,CAAAA;;AAKA,SAAA,SAAA,CAAA,CAAA,EAAA,OAAA,EAAA,OAAA,EAAyC;AACvC,MAAI,OAAA,OAAA,KAAJ,QAAA,EAAiC;AAC/B,UAAM,IAAA,SAAA,CAAN,8BAAM,CAAN;AACD;;AAED,MAAI,CAAJ,OAAA,EAAca,OAAO,GALkB,EAKzBA,CALyB,CAOvC;;AACA,MAAI,CAACA,OAAO,CAAR,SAAA,IAAsBQ,OAAO,CAAPA,MAAAA,CAAAA,CAAAA,MAA1B,GAAA,EAAqD;AACnD,WAAA,KAAA;AATqC,GAAA,CAYvC;;;AACA,MAAIA,OAAO,CAAPA,IAAAA,OAAJ,EAAA,EAA2B,OAAOC,CAAC,KAAR,EAAA;AAE3B,SAAO,IAAA,SAAA,CAAA,OAAA,EAAA,OAAA,EAAA,KAAA,CAAP,CAAO,CAAP;AACD;;AAED,SAAA,SAAA,CAAA,OAAA,EAAA,OAAA,EAAsC;AACpC,MAAI,EAAE,gBAAN,SAAI,CAAJ,EAAkC;AAChC,WAAO,IAAA,SAAA,CAAA,OAAA,EAAP,OAAO,CAAP;AACD;;AAED,MAAI,OAAA,OAAA,KAAJ,QAAA,EAAiC;AAC/B,UAAM,IAAA,SAAA,CAAN,8BAAM,CAAN;AACD;;AAED,MAAI,CAAJ,OAAA,EAAcT,OAAO,GAAPA,EAAAA;AACdQ,EAAAA,OAAO,GAAGA,OAAO,CAVmB,IAU1BA,EAAVA,CAVoC,CAYpC;;AACA,MAAIzB,IAAI,CAAJA,GAAAA,KAAJ,GAAA,EAAsB;AACpByB,IAAAA,OAAO,GAAGA,OAAO,CAAPA,KAAAA,CAAczB,IAAI,CAAlByB,GAAAA,EAAAA,IAAAA,CAAVA,GAAUA,CAAVA;AACD;;AAED,OAAA,OAAA,GAAA,OAAA;AACA,OAAA,GAAA,GAAA,EAAA;AACA,OAAA,OAAA,GAAA,OAAA;AACA,OAAA,MAAA,GAAA,IAAA;AACA,OAAA,MAAA,GAAA,KAAA;AACA,OAAA,OAAA,GAAA,KAAA;AACA,OAAA,KAAA,GAvBoC,KAuBpC,CAvBoC,CAyBpC;;AACA,OAAA,IAAA;AACD;;AAEDrB,SAAS,CAATA,SAAAA,CAAAA,KAAAA,GAA4B,YAAY,CAAxCA,CAAAA;;AAEAA,SAAS,CAATA,SAAAA,CAAAA,IAAAA,GAAAA,IAAAA;;AACA,SAAA,IAAA,GAAiB;AACf;AACA,MAAI,KAAJ,KAAA,EAAgB;AAEhB,MAAIqB,OAAO,GAAG,KAAd,OAAA;AACA,MAAIR,OAAO,GAAG,KALC,OAKf,CALe,CAOf;;AACA,MAAI,CAACA,OAAO,CAAR,SAAA,IAAsBQ,OAAO,CAAPA,MAAAA,CAAAA,CAAAA,MAA1B,GAAA,EAAqD;AACnD,SAAA,OAAA,GAAA,IAAA;AACA;AACD;;AACD,MAAI,CAAJ,OAAA,EAAc;AACZ,SAAA,KAAA,GAAA,IAAA;AACA;AAda,GAAA,CAiBf;;;AACA,OAlBe,WAkBf,GAlBe,CAoBf;;AACA,MAAIV,GAAG,GAAG,KAAA,OAAA,GAAe,KAAzB,WAAyB,EAAzB;AAEA,MAAIE,OAAO,CAAX,KAAA,EAAmB,KAAA,KAAA,GAAaU,OAAO,CAApB,KAAA;AAEnB,OAAA,KAAA,CAAW,KAAX,OAAA,EAzBe,GAyBf,EAzBe,CA2Bf;AACA;AACA;AACA;AACA;;AACAZ,EAAAA,GAAG,GAAG,KAAA,SAAA,GAAiB,GAAG,CAAH,GAAA,CAAQ,UAAA,CAAA,EAAa;AAC1C,WAAOa,CAAC,CAADA,KAAAA,CAAP,UAAOA,CAAP;AADFb,GAAuB,CAAvBA;AAIA,OAAA,KAAA,CAAW,KAAX,OAAA,EApCe,GAoCf,EApCe,CAsCf;;AACAA,EAAAA,GAAG,GAAG,GAAG,CAAH,GAAA,CAAQ,UAAA,CAAA,EAAA,EAAA,EAAA,GAAA,EAAsB;AAClC,WAAOa,CAAC,CAADA,GAAAA,CAAM,KAANA,KAAAA,EAAP,IAAOA,CAAP;AADI,GAAA,EAANb,IAAM,CAANA;AAIA,OAAA,KAAA,CAAW,KAAX,OAAA,EA3Ce,GA2Cf,EA3Ce,CA6Cf;;AACAA,EAAAA,GAAG,GAAG,GAAG,CAAH,MAAA,CAAW,UAAA,CAAA,EAAa;AAC5B,WAAOa,CAAC,CAADA,OAAAA,CAAAA,KAAAA,MAAqB,CAA5B,CAAA;AADFb,GAAM,CAANA;AAIA,OAAA,KAAA,CAAW,KAAX,OAAA,EAAA,GAAA;AAEA,OAAA,GAAA,GAAA,GAAA;AACD;;AAEDX,SAAS,CAATA,SAAAA,CAAAA,WAAAA,GAAAA,WAAAA;;AACA,SAAA,WAAA,GAAwB;AACtB,MAAIqB,OAAO,GAAG,KAAd,OAAA;AACA,MAAII,MAAM,GAAV,KAAA;AACA,MAAIZ,OAAO,GAAG,KAAd,OAAA;AACA,MAAIa,YAAY,GAAhB,CAAA;AAEA,MAAIb,OAAO,CAAX,QAAA,EAAsB;;AAEtB,OAAK,IAAIc,CAAC,GAAL,CAAA,EAAWC,CAAC,GAAGP,OAAO,CAA3B,MAAA,EACIM,CAAC,GAADA,CAAAA,IAASN,OAAO,CAAPA,MAAAA,CAAAA,CAAAA,MADb,GAAA,EAEIM,CAFJ,EAAA,EAES;AACPF,IAAAA,MAAM,GAAG,CAATA,MAAAA;AACAC,IAAAA,YAAY;AACb;;AAED,MAAA,YAAA,EAAkB,KAAA,OAAA,GAAeL,OAAO,CAAPA,MAAAA,CAAf,YAAeA,CAAf;AAClB,OAAA,MAAA,GAAA,MAAA;EAGF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA1B,SAAS,CAATA,WAAAA,GAAwB,UAAA,OAAA,EAAA,OAAA,EAA4B;AAClD,SAAOkC,WAAW,CAAA,OAAA,EAAlB,OAAkB,CAAlB;AADFlC,CAAAA;;AAIAK,SAAS,CAATA,SAAAA,CAAAA,WAAAA,GAAAA,WAAAA;;AAEA,SAAA,WAAA,CAAA,OAAA,EAAA,OAAA,EAAwC;AACtC,MAAI,CAAJ,OAAA,EAAc;AACZ,QAAI,gBAAJ,SAAA,EAA+B;AAC7Ba,MAAAA,OAAO,GAAG,KAAVA,OAAAA;AADF,KAAA,MAEO;AACLA,MAAAA,OAAO,GAAPA,EAAAA;AACD;AACF;;AAEDQ,EAAAA,OAAO,GAAG,OAAA,OAAA,KAAA,WAAA,GACN,KADM,OAAA,GAAVA,OAAAA;;AAGA,MAAI,OAAA,OAAA,KAAJ,WAAA,EAAoC;AAClC,UAAM,IAAA,SAAA,CAAN,mBAAM,CAAN;AACD;;AAED,MAAIR,OAAO,CAAPA,OAAAA,IACF,CAACQ,OAAO,CAAPA,KAAAA,CADH,QACGA,CADH,EAC4B;AAC1B;AACA,WAAO,CAAP,OAAO,CAAP;AACD;;AAED,SAAOpB,MAAM,CAAb,OAAa,CAAb;EAGF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAD,SAAS,CAATA,SAAAA,CAAAA,KAAAA,GAAAA,KAAAA;AACA,IAAI8B,QAAQ,GAAZ,EAAA;;AACA,SAAA,KAAA,CAAA,OAAA,EAAA,KAAA,EAAgC;AAC9B,MAAIT,OAAO,CAAPA,MAAAA,GAAiB,OAArB,EAAA,EAAgC;AAC9B,UAAM,IAAA,SAAA,CAAN,qBAAM,CAAN;AACD;;AAED,MAAIR,OAAO,GAAG,KALgB,OAK9B,CAL8B,CAO9B;;AACA,MAAI,CAACA,OAAO,CAAR,UAAA,IAAuBQ,OAAO,KAAlC,IAAA,EAA6C,OAAA,QAAA;AAC7C,MAAIA,OAAO,KAAX,EAAA,EAAoB,OAAA,EAAA;AAEpB,MAAIU,EAAE,GAAN,EAAA;AACA,MAAIC,QAAQ,GAAG,CAAC,CAACnB,OAAO,CAAxB,MAAA;AACA,MAAIoB,QAAQ,GAbkB,KAa9B,CAb8B,CAc9B;;AACA,MAAIC,gBAAgB,GAApB,EAAA;AACA,MAAIC,aAAa,GAAjB,EAAA;AACA,MAAA,SAAA;AACA,MAAIC,OAAO,GAAX,KAAA;AACA,MAAIC,YAAY,GAAG,CAAnB,CAAA;AACA,MAAIC,UAAU,GAAG,CApBa,CAoB9B,CApB8B,CAqB9B;AACA;;AACA,MAAIC,YAAY,GAAG,OAAO,CAAP,MAAA,CAAA,CAAA,MAAA,GAAA,GAAA,EAAA,CAA+B;AAClD;AADmB,IAEjB1B,OAAO,CAAPA,GAAAA,GAAAA,kCAAAA,GAFF,SAAA;AAIA,MAAI2B,IAAI,GAAR,IAAA;;AAEA,WAAA,cAAA,GAA2B;AACzB,QAAA,SAAA,EAAe;AACb;AACA;AACA,cAAA,SAAA;AACE,aAAA,GAAA;AACET,UAAAA,EAAE,IAAFA,IAAAA;AACAC,UAAAA,QAAQ,GAARA,IAAAA;AACF;;AACA,aAAA,GAAA;AACED,UAAAA,EAAE,IAAFA,KAAAA;AACAC,UAAAA,QAAQ,GAARA,IAAAA;AACF;;AACA;AACED,UAAAA,EAAE,IAAI,OAANA,SAAAA;AACF;AAXF;;AAaAS,MAAAA,IAAI,CAAJA,KAAAA,CAAAA,sBAAAA,EAAAA,SAAAA,EAAAA,EAAAA;AACAC,MAAAA,SAAS,GAATA,KAAAA;AACD;AACF;;AAED,OAAK,IAAId,CAAC,GAAL,CAAA,EAAWe,GAAG,GAAGrB,OAAO,CAAxB,MAAA,EAAL,CAAA,EACKM,CAAC,GAAF,GAACA,KAAagB,CAAC,GAAGtB,OAAO,CAAPA,MAAAA,CADtB,CACsBA,CAAjBM,CADL,EAEIA,CAFJ,EAAA,EAES;AACP,SAAA,KAAA,CAAA,cAAA,EAAA,OAAA,EAAA,CAAA,EAAA,EAAA,EADO,CACP,EADO,CAGP;;AACA,QAAIM,QAAQ,IAAIxB,UAAU,CAA1B,CAA0B,CAA1B,EAA+B;AAC7BsB,MAAAA,EAAE,IAAI,OAANA,CAAAA;AACAE,MAAAA,QAAQ,GAARA,KAAAA;AACA;AACD;;AAED,YAAA,CAAA;AACE,WAAA,GAAA;AACE;AACA;AACA,eAAA,KAAA;;AAEF,WAAA,IAAA;AACEW,QAAAA,cAAc;AACdX,QAAAA,QAAQ,GAARA,IAAAA;AACF;AAEA;AACA;;AACA,WAAA,GAAA;AACA,WAAA,GAAA;AACA,WAAA,GAAA;AACA,WAAA,GAAA;AACA,WAAA,GAAA;AACE,aAAA,KAAA,CAAA,4BAAA,EAAA,OAAA,EAAA,CAAA,EAAA,EAAA,EADF,CACE,EADF,CAGE;AACA;;AACA,YAAA,OAAA,EAAa;AACX,eAAA,KAAA,CAAA,YAAA;AACA,cAAIU,CAAC,KAADA,GAAAA,IAAahB,CAAC,KAAKW,UAAU,GAAjC,CAAA,EAAuCK,CAAC,GAADA,GAAAA;AACvCZ,UAAAA,EAAE,IAAFA,CAAAA;AACA;AATJ,SAAA,CAYE;AACA;AACA;;;AACAS,QAAAA,IAAI,CAAJA,KAAAA,CAAAA,wBAAAA,EAAAA,SAAAA;AACAI,QAAAA,cAAc;AACdH,QAAAA,SAAS,GAjBX,CAiBEA,CAjBF,CAkBE;AACA;AACA;;AACA,YAAI5B,OAAO,CAAX,KAAA,EAAmB+B,cAAc;AACnC;;AAEA,WAAA,GAAA;AACE,YAAA,OAAA,EAAa;AACXb,UAAAA,EAAE,IAAFA,GAAAA;AACA;AACD;;AAED,YAAI,CAAJ,SAAA,EAAgB;AACdA,UAAAA,EAAE,IAAFA,KAAAA;AACA;AACD;;AAEDG,QAAAA,gBAAgB,CAAhBA,IAAAA,CAAsB;AACpBW,UAAAA,IAAI,EADgB,SAAA;AAEpBC,UAAAA,KAAK,EAAEnB,CAAC,GAFY,CAAA;AAGpBoB,UAAAA,OAAO,EAAEhB,EAAE,CAHS,MAAA;AAIpB5B,UAAAA,IAAI,EAAED,OAAO,CAAPA,SAAO,CAAPA,CAJc,IAAA;AAKpBE,UAAAA,KAAK,EAAEF,OAAO,CAAPA,SAAO,CAAPA,CAAmBE;AALN,SAAtB8B,EAXF,CAkBE;;AACAH,QAAAA,EAAE,IAAIU,SAAS,KAATA,GAAAA,GAAAA,WAAAA,GAANV,KAAAA;AACA,aAAA,KAAA,CAAA,cAAA,EAAA,SAAA,EAAA,EAAA;AACAU,QAAAA,SAAS,GAATA,KAAAA;AACF;;AAEA,WAAA,GAAA;AACE,YAAIL,OAAO,IAAI,CAACF,gBAAgB,CAAhC,MAAA,EAAyC;AACvCH,UAAAA,EAAE,IAAFA,KAAAA;AACA;AACD;;AAEDa,QAAAA,cAAc;AACdZ,QAAAA,QAAQ,GAARA,IAAAA;AACA,YAAIgB,EAAE,GAAGd,gBAAgB,CAR3B,GAQWA,EAAT,CARF,CASE;AACA;;AACAH,QAAAA,EAAE,IAAIiB,EAAE,CAARjB,KAAAA;;AACA,YAAIiB,EAAE,CAAFA,IAAAA,KAAJ,GAAA,EAAqB;AACnBb,UAAAA,aAAa,CAAbA,IAAAA,CAAAA,EAAAA;AACD;;AACDa,QAAAA,EAAE,CAAFA,KAAAA,GAAWjB,EAAE,CAAbiB,MAAAA;AACF;;AAEA,WAAA,GAAA;AACE,YAAIZ,OAAO,IAAI,CAACF,gBAAgB,CAA5BE,MAAAA,IAAJ,QAAA,EAAqD;AACnDL,UAAAA,EAAE,IAAFA,KAAAA;AACAE,UAAAA,QAAQ,GAARA,KAAAA;AACA;AACD;;AAEDW,QAAAA,cAAc;AACdb,QAAAA,EAAE,IAAFA,GAAAA;AACF;AAEA;;AACA,WAAA,GAAA;AACE;AACAa,QAAAA,cAAc;;AAEd,YAAA,OAAA,EAAa;AACXb,UAAAA,EAAE,IAAI,OAANA,CAAAA;AACA;AACD;;AAEDK,QAAAA,OAAO,GAAPA,IAAAA;AACAE,QAAAA,UAAU,GAAVA,CAAAA;AACAD,QAAAA,YAAY,GAAGN,EAAE,CAAjBM,MAAAA;AACAN,QAAAA,EAAE,IAAFA,CAAAA;AACF;;AAEA,WAAA,GAAA;AACE;AACA;AACA;AACA;AACA,YAAIJ,CAAC,KAAKW,UAAU,GAAhBX,CAAAA,IAAwB,CAA5B,OAAA,EAAsC;AACpCI,UAAAA,EAAE,IAAI,OAANA,CAAAA;AACAE,UAAAA,QAAQ,GAARA,KAAAA;AACA;AARJ,SAAA,CAWE;AACA;;;AACA,YAAA,OAAA,EAAa;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAIgB,EAAE,GAAG5B,OAAO,CAAPA,SAAAA,CAAkBiB,UAAU,GAA5BjB,CAAAA,EAAT,CAASA,CAAT;;AACA,cAAI;AACF6B,YAAAA,MAAM,CAAC,MAAA,EAAA,GAAPA,GAAM,CAANA;AADF,WAAA,CAEE,OAAA,EAAA,EAAW;AACX;AACA,gBAAIC,EAAE,GAAG,KAAA,KAAA,CAAA,EAAA,EAAT,QAAS,CAAT;AACApB,YAAAA,EAAE,GAAGA,EAAE,CAAFA,MAAAA,CAAAA,CAAAA,EAAAA,YAAAA,IAAAA,KAAAA,GAAqCoB,EAAE,CAAvCpB,CAAuC,CAAvCA,GAALA,KAAAA;AACAC,YAAAA,QAAQ,GAAGA,QAAQ,IAAImB,EAAE,CAAzBnB,CAAyB,CAAzBA;AACAI,YAAAA,OAAO,GAAPA,KAAAA;AACA;AACD;AA/BL,SAAA,CAkCE;;;AACAJ,QAAAA,QAAQ,GAARA,IAAAA;AACAI,QAAAA,OAAO,GAAPA,KAAAA;AACAL,QAAAA,EAAE,IAAFA,CAAAA;AACF;;AAEA;AACE;AACAa,QAAAA,cAAc;;AAEd,YAAA,QAAA,EAAc;AACZ;AACAX,UAAAA,QAAQ,GAARA,KAAAA;AAFF,SAAA,MAGO,IAAIxB,UAAU,CAAVA,CAAU,CAAVA,IACN,EAAEkC,CAAC,KAADA,GAAAA,IADA,OACF,CADE,EACuB;AAC5BZ,UAAAA,EAAE,IAAFA,IAAAA;AACD;;AAEDA,QAAAA,EAAE,IAAFA,CAAAA;AAlKJ,KAVO,CA8KL;;AAnO0B,GAAA,CAoO5B;AAEF;AACA;;;AACA,MAAA,OAAA,EAAa;AACX;AACA;AACA;AACA;AACAkB,IAAAA,EAAE,GAAG5B,OAAO,CAAPA,MAAAA,CAAeiB,UAAU,GAA9BW,CAAK5B,CAAL4B;AACAE,IAAAA,EAAE,GAAG,KAAA,KAAA,CAAA,EAAA,EAALA,QAAK,CAALA;AACApB,IAAAA,EAAE,GAAGA,EAAE,CAAFA,MAAAA,CAAAA,CAAAA,EAAAA,YAAAA,IAAAA,KAAAA,GAAqCoB,EAAE,CAA5CpB,CAA4C,CAA5CA;AACAC,IAAAA,QAAQ,GAAGA,QAAQ,IAAImB,EAAE,CAAzBnB,CAAyB,CAAzBA;AAhP4B,GAAA,CAmP9B;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAKgB,EAAE,GAAGd,gBAAgB,CAA1B,GAAUA,EAAV,EAAA,EAAA,EAAsCc,EAAE,GAAGd,gBAAgB,CAA3D,GAA2CA,EAA3C,EAAmE;AACjE,QAAIkB,IAAI,GAAGrB,EAAE,CAAFA,KAAAA,CAASiB,EAAE,CAAFA,OAAAA,GAAaA,EAAE,CAAFA,IAAAA,CAAjC,MAAWjB,CAAX;AACA,SAAA,KAAA,CAAA,cAAA,EAAA,EAAA,EAFiE,EAEjE,EAFiE,CAGjE;;AACAqB,IAAAA,IAAI,GAAG,IAAI,CAAJ,OAAA,CAAA,2BAAA,EAA0C,UAAA,CAAA,EAAA,EAAA,EAAA,EAAA,EAAqB;AACpE,UAAI,CAAJ,EAAA,EAAS;AACP;AACAC,QAAAA,EAAE,GAAFA,IAAAA;AAHkE,OAAA,CAMpE;AACA;AACA;AACA;AACA;AACA;;;AACA,aAAOC,EAAE,GAAFA,EAAAA,GAAAA,EAAAA,GAAP,GAAA;AAZFF,KAAO,CAAPA;AAeA,SAAA,KAAA,CAAA,gBAAA,EAAA,IAAA,EAAA,IAAA,EAAA,EAAA,EAAA,EAAA;AACA,QAAIpC,CAAC,GAAGgC,EAAE,CAAFA,IAAAA,KAAAA,GAAAA,GAAAA,IAAAA,GACJA,EAAE,CAAFA,IAAAA,KAAAA,GAAAA,GAAAA,KAAAA,GACA,OAAOA,EAAE,CAFb,IAAA;AAIAhB,IAAAA,QAAQ,GAARA,IAAAA;AACAD,IAAAA,EAAE,GAAGA,EAAE,CAAFA,KAAAA,CAAAA,CAAAA,EAAYiB,EAAE,CAAdjB,OAAAA,IAAAA,CAAAA,GAAAA,KAAAA,GAALA,IAAAA;AAlR4B,GAAA,CAqR9B;;;AACAa,EAAAA,cAAc;;AACd,MAAA,QAAA,EAAc;AACZ;AACAb,IAAAA,EAAE,IAAFA,MAAAA;AAzR4B,GAAA,CA4R9B;AACA;;;AACA,MAAIwB,eAAe,GAAnB,KAAA;;AACA,UAAQxB,EAAE,CAAFA,MAAAA,CAAR,CAAQA,CAAR;AACE,SAAA,GAAA;AACA,SAAA,GAAA;AACA,SAAA,GAAA;AAAUwB,MAAAA,eAAe,GAAfA,IAAAA;AAHZ,GA/R8B,CAqS9B;AACA;AACA;AACA;AACA;;;AACA,OAAK,IAAIC,CAAC,GAAGrB,aAAa,CAAbA,MAAAA,GAAb,CAAA,EAAuCqB,CAAC,GAAG,CAA3C,CAAA,EAA+CA,CAA/C,EAAA,EAAoD;AAClD,QAAIC,EAAE,GAAGtB,aAAa,CAAtB,CAAsB,CAAtB;AAEA,QAAIuB,QAAQ,GAAG3B,EAAE,CAAFA,KAAAA,CAAAA,CAAAA,EAAY0B,EAAE,CAA7B,OAAe1B,CAAf;AACA,QAAI4B,OAAO,GAAG5B,EAAE,CAAFA,KAAAA,CAAS0B,EAAE,CAAX1B,OAAAA,EAAqB0B,EAAE,CAAFA,KAAAA,GAAnC,CAAc1B,CAAd;AACA,QAAI6B,MAAM,GAAG7B,EAAE,CAAFA,KAAAA,CAAS0B,EAAE,CAAFA,KAAAA,GAAT1B,CAAAA,EAAuB0B,EAAE,CAAtC,KAAa1B,CAAb;AACA,QAAI8B,OAAO,GAAG9B,EAAE,CAAFA,KAAAA,CAAS0B,EAAE,CAAzB,KAAc1B,CAAd;AAEA6B,IAAAA,MAAM,IAR4C,OAQlDA,CARkD,CAUlD;AACA;AACA;;AACA,QAAIE,gBAAgB,GAAGJ,QAAQ,CAARA,KAAAA,CAAAA,GAAAA,EAAAA,MAAAA,GAAvB,CAAA;AACA,QAAIK,UAAU,GAAd,OAAA;;AACA,SAAKpC,CAAC,GAAN,CAAA,EAAYA,CAAC,GAAb,gBAAA,EAAkCA,CAAlC,EAAA,EAAuC;AACrCoC,MAAAA,UAAU,GAAGA,UAAU,CAAVA,OAAAA,CAAAA,UAAAA,EAAbA,EAAaA,CAAbA;AACD;;AACDF,IAAAA,OAAO,GAAPA,UAAAA;AAEA,QAAIG,MAAM,GAAV,EAAA;;AACA,QAAIH,OAAO,KAAPA,EAAAA,IAAkBI,KAAK,KAA3B,QAAA,EAA0C;AACxCD,MAAAA,MAAM,GAANA,GAAAA;AACD;;AACD,QAAIE,KAAK,GAAGR,QAAQ,GAARA,OAAAA,GAAAA,OAAAA,GAAAA,MAAAA,GAAZ,MAAA;AACA3B,IAAAA,EAAE,GAAFA,KAAAA;AAnU4B,GAAA,CAsU9B;AACA;AACA;;;AACA,MAAIA,EAAE,KAAFA,EAAAA,IAAJ,QAAA,EAA2B;AACzBA,IAAAA,EAAE,GAAG,UAALA,EAAAA;AACD;;AAED,MAAA,eAAA,EAAqB;AACnBA,IAAAA,EAAE,GAAGQ,YAAY,GAAjBR,EAAAA;AA9U4B,GAAA,CAiV9B;;;AACA,MAAIkC,KAAK,KAAT,QAAA,EAAwB;AACtB,WAAO,CAAA,EAAA,EAAP,QAAO,CAAP;AAnV4B,GAAA,CAsV9B;AACA;AACA;;;AACA,MAAI,CAAJ,QAAA,EAAe;AACb,WAAOE,YAAY,CAAnB,OAAmB,CAAnB;AACD;;AAED,MAAIC,KAAK,GAAGvD,OAAO,CAAPA,MAAAA,GAAAA,GAAAA,GAAZ,EAAA;;AACA,MAAI;AACF,QAAIwD,MAAM,GAAG,IAAA,MAAA,CAAW,MAAA,EAAA,GAAX,GAAA,EAAb,KAAa,CAAb;AADF,GAAA,CAEE,OAAA,EAAA,EAAW;AACX;AACA;AACA;AACA;AACA,WAAO,IAAA,MAAA,CAAP,IAAO,CAAP;AACD;;AAEDA,EAAAA,MAAM,CAANA,KAAAA,GAAAA,OAAAA;AACAA,EAAAA,MAAM,CAANA,IAAAA,GAAAA,EAAAA;AAEA,SAAA,MAAA;AACD;;AAED1E,SAAS,CAATA,MAAAA,GAAmB,UAAA,OAAA,EAAA,OAAA,EAA4B;AAC7C,SAAO,IAAA,SAAA,CAAA,OAAA,EAAuBkB,OAAO,IAA9B,EAAA,EAAP,MAAO,EAAP;AADFlB,CAAAA;;AAIAK,SAAS,CAATA,SAAAA,CAAAA,MAAAA,GAAAA,MAAAA;;AACA,SAAA,MAAA,GAAmB;AACjB,MAAI,KAAA,MAAA,IAAe,KAAA,MAAA,KAAnB,KAAA,EAA0C,OAAO,KADhC,MACyB,CADzB,CAGjB;AACA;AACA;AACA;AACA;AACA;;AACA,MAAIW,GAAG,GAAG,KAAV,GAAA;;AAEA,MAAI,CAACA,GAAG,CAAR,MAAA,EAAiB;AACf,SAAA,MAAA,GAAA,KAAA;AACA,WAAO,KAAP,MAAA;AACD;;AACD,MAAIE,OAAO,GAAG,KAAd,OAAA;AAEA,MAAIyD,OAAO,GAAGzD,OAAO,CAAPA,UAAAA,GAAAA,IAAAA,GACVA,OAAO,CAAPA,GAAAA,GAAAA,UAAAA,GADJ,YAAA;AAGA,MAAIuD,KAAK,GAAGvD,OAAO,CAAPA,MAAAA,GAAAA,GAAAA,GAAZ,EAAA;AAEA,MAAIkB,EAAE,GAAG,GAAG,CAAH,GAAA,CAAQ,UAAA,OAAA,EAAmB;AAClC,WAAO,OAAO,CAAP,GAAA,CAAY,UAAA,CAAA,EAAa;AAC9B,aAAQT,CAAC,KAAF,QAACA,GAAD,OAACA,GACL,OAAA,CAAA,KAAD,QAAC,GAAyBiD,YAAY,CAAtC,CAAsC,CAArC,GACDjD,CAAC,CAFH,IAAA;AADK,KAAA,EAAA,IAAA,CAAP,MAAO,CAAP;AADO,GAAA,EAAA,IAAA,CAtBQ,GAsBR,CAAT,CAtBiB,CA8BjB;AACA;;AACAS,EAAAA,EAAE,GAAG,SAAA,EAAA,GAhCY,IAgCjBA,CAhCiB,CAkCjB;;AACA,MAAI,KAAJ,MAAA,EAAiBA,EAAE,GAAG,SAAA,EAAA,GAALA,MAAAA;;AAEjB,MAAI;AACF,SAAA,MAAA,GAAc,IAAA,MAAA,CAAA,EAAA,EAAd,KAAc,CAAd;AADF,GAAA,CAEE,OAAA,EAAA,EAAW;AACX,SAAA,MAAA,GAAA,KAAA;AACD;;AACD,SAAO,KAAP,MAAA;AACD;;AAEDpC,SAAS,CAATA,KAAAA,GAAkB,UAAA,IAAA,EAAA,OAAA,EAAA,OAAA,EAAkC;AAClDkB,EAAAA,OAAO,GAAGA,OAAO,IAAjBA,EAAAA;AACA,MAAI2D,EAAE,GAAG,IAAA,SAAA,CAAA,OAAA,EAAT,OAAS,CAAT;AACAC,EAAAA,IAAI,GAAG,IAAI,CAAJ,MAAA,CAAY,UAAA,CAAA,EAAa;AAC9B,WAAOD,EAAE,CAAFA,KAAAA,CAAP,CAAOA,CAAP;AADFC,GAAO,CAAPA;;AAGA,MAAID,EAAE,CAAFA,OAAAA,CAAAA,MAAAA,IAAqB,CAACC,IAAI,CAA9B,MAAA,EAAuC;AACrCA,IAAAA,IAAI,CAAJA,IAAAA,CAAAA,OAAAA;AACD;;AACD,SAAA,IAAA;AATF9E,CAAAA;;AAYAK,SAAS,CAATA,SAAAA,CAAAA,KAAAA,GAAAA,KAAAA;;AACA,SAAA,KAAA,CAAA,CAAA,EAAA,OAAA,EAA4B;AAC1B,OAAA,KAAA,CAAA,OAAA,EAAA,CAAA,EAAuB,KADG,OAC1B,EAD0B,CAE1B;AACA;;AACA,MAAI,KAAJ,OAAA,EAAkB,OAAA,KAAA;AAClB,MAAI,KAAJ,KAAA,EAAgB,OAAO0E,CAAC,KAAR,EAAA;AAEhB,MAAIA,CAAC,KAADA,GAAAA,IAAJ,OAAA,EAA0B,OAAA,IAAA;AAE1B,MAAI7D,OAAO,GAAG,KATY,OAS1B,CAT0B,CAW1B;;AACA,MAAIjB,IAAI,CAAJA,GAAAA,KAAJ,GAAA,EAAsB;AACpB8E,IAAAA,CAAC,GAAGA,CAAC,CAADA,KAAAA,CAAQ9E,IAAI,CAAZ8E,GAAAA,EAAAA,IAAAA,CAAJA,GAAIA,CAAJA;AAbwB,GAAA,CAgB1B;;;AACAA,EAAAA,CAAC,GAAGA,CAAC,CAADA,KAAAA,CAAJA,UAAIA,CAAJA;AACA,OAAA,KAAA,CAAW,KAAX,OAAA,EAAA,OAAA,EAlB0B,CAkB1B,EAlB0B,CAoB1B;AACA;AACA;AACA;;AAEA,MAAI/D,GAAG,GAAG,KAAV,GAAA;AACA,OAAA,KAAA,CAAW,KAAX,OAAA,EAAA,KAAA,EA1B0B,GA0B1B,EA1B0B,CA4B1B;;AACA,MAAA,QAAA;AACA,MAAA,CAAA;;AACA,OAAKgB,CAAC,GAAG+C,CAAC,CAADA,MAAAA,GAAT,CAAA,EAAuB/C,CAAC,IAAxB,CAAA,EAA+BA,CAA/B,EAAA,EAAoC;AAClCgD,IAAAA,QAAQ,GAAGD,CAAC,CAAZC,CAAY,CAAZA;AACA,QAAA,QAAA,EAAc;AACf;;AAED,OAAKhD,CAAC,GAAN,CAAA,EAAYA,CAAC,GAAGhB,GAAG,CAAnB,MAAA,EAA4BgB,CAA5B,EAAA,EAAiC;AAC/B,QAAIN,OAAO,GAAGV,GAAG,CAAjB,CAAiB,CAAjB;AACA,QAAIiE,IAAI,GAAR,CAAA;;AACA,QAAI/D,OAAO,CAAPA,SAAAA,IAAqBQ,OAAO,CAAPA,MAAAA,KAAzB,CAAA,EAA+C;AAC7CuD,MAAAA,IAAI,GAAG,CAAPA,QAAO,CAAPA;AACD;;AACD,QAAIC,GAAG,GAAG,KAAA,QAAA,CAAA,IAAA,EAAA,OAAA,EAAV,OAAU,CAAV;;AACA,QAAA,GAAA,EAAS;AACP,UAAIhE,OAAO,CAAX,UAAA,EAAwB,OAAA,IAAA;AACxB,aAAO,CAAC,KAAR,MAAA;AACD;AA9CuB,GAAA,CAiD1B;AACA;;;AACA,MAAIA,OAAO,CAAX,UAAA,EAAwB,OAAA,KAAA;AACxB,SAAO,KAAP,MAAA;EAGF;AACA;AACA;AACA;AACA;;;AACAb,SAAS,CAATA,SAAAA,CAAAA,QAAAA,GAA+B,UAAA,IAAA,EAAA,OAAA,EAAA,OAAA,EAAkC;AAC/D,MAAIa,OAAO,GAAG,KAAd,OAAA;AAEA,OAAA,KAAA,CAAA,UAAA,EACE;AAAE,YAAF,IAAA;AAAgB+D,IAAAA,IAAI,EAApB,IAAA;AAA4BvD,IAAAA,OAAO,EAAEA;AAArC,GADF;AAGA,OAAA,KAAA,CAAA,UAAA,EAAuBuD,IAAI,CAA3B,MAAA,EAAoCvD,OAAO,CAA3C,MAAA;;AAEA,OAAK,IAAIyD,EAAE,GAAN,CAAA,EACDC,EAAE,GADD,CAAA,EAEDC,EAAE,GAAGJ,IAAI,CAFR,MAAA,EAGD5B,EAAE,GAAG3B,OAAO,CAHhB,MAAA,EAIOyD,EAAE,GAAH,EAACA,IAAaC,EAAE,GAJtB,EAAA,EAKMD,EAAE,IAAIC,EALZ,EAAA,EAKkB;AAChB,SAAA,KAAA,CAAA,eAAA;AACA,QAAIzD,CAAC,GAAGD,OAAO,CAAf,EAAe,CAAf;AACA,QAAIqD,CAAC,GAAGE,IAAI,CAAZ,EAAY,CAAZ;AAEA,SAAA,KAAA,CAAA,OAAA,EAAA,CAAA,EALgB,CAKhB,EALgB,CAOhB;AACA;;AACA,QAAItD,CAAC,KAAL,KAAA,EAAiB,OAAA,KAAA;;AAEjB,QAAIA,CAAC,KAAL,QAAA,EAAoB;AAClB,WAAA,KAAA,CAAA,UAAA,EAAuB,CAAA,OAAA,EAAA,CAAA,EADL,CACK,CAAvB,EADkB,CAGlB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,UAAI2D,EAAE,GAAN,EAAA;AACA,UAAIC,EAAE,GAAGH,EAAE,GAAX,CAAA;;AACA,UAAIG,EAAE,KAAN,EAAA,EAAe;AACb,aAAA,KAAA,CADa,eACb,EADa,CAEb;AACA;AACA;AACA;AACA;AACA;;AACA,eAAOJ,EAAE,GAAT,EAAA,EAAgBA,EAAhB,EAAA,EAAsB;AACpB,cAAIF,IAAI,CAAJA,EAAI,CAAJA,KAAAA,GAAAA,IAAoBA,IAAI,CAAJA,EAAI,CAAJA,KAApBA,IAAAA,IACD,CAAC/D,OAAO,CAAR,GAAA,IAAgB+D,IAAI,CAAJA,EAAI,CAAJA,CAAAA,MAAAA,CAAAA,CAAAA,MADnB,GAAA,EACgD,OAAA,KAAA;AACjD;;AACD,eAAA,IAAA;AAvCgB,OAAA,CA0ClB;;;AACA,aAAOK,EAAE,GAAT,EAAA,EAAgB;AACd,YAAIE,SAAS,GAAGP,IAAI,CAApB,EAAoB,CAApB;AAEA,aAAA,KAAA,CAAA,kBAAA,EAAA,IAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,EAHc,SAGd,EAHc,CAKd;;AACA,YAAI,KAAA,QAAA,CAAcA,IAAI,CAAJA,KAAAA,CAAd,EAAcA,CAAd,EAA8BvD,OAAO,CAAPA,KAAAA,CAA9B,EAA8BA,CAA9B,EAAJ,OAAI,CAAJ,EAA+D;AAC7D,eAAA,KAAA,CAAA,uBAAA,EAAA,EAAA,EAAA,EAAA,EAD6D,SAC7D,EAD6D,CAE7D;;AACA,iBAAA,IAAA;AAHF,SAAA,MAIO;AACL;AACA;AACA,cAAI8D,SAAS,KAATA,GAAAA,IAAqBA,SAAS,KAA9BA,IAAAA,IACD,CAACtE,OAAO,CAAR,GAAA,IAAgBsE,SAAS,CAATA,MAAAA,CAAAA,CAAAA,MADnB,GAAA,EACiD;AAC/C,iBAAA,KAAA,CAAA,eAAA,EAAA,IAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA;AACA;AANG,WAAA,CASL;;;AACA,eAAA,KAAA,CAAA,0CAAA;AACAF,UAAAA,EAAE;AACH;AAjEe,OAAA,CAoElB;AACA;AACA;;;AACA,UAAA,OAAA,EAAa;AACX;AACA,aAAA,KAAA,CAAA,0BAAA,EAAA,IAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA;AACA,YAAIA,EAAE,KAAN,EAAA,EAAe,OAAA,IAAA;AAChB;;AACD,aAAA,KAAA;AAvFc,KAAA,CA0FhB;AACA;AACA;;;AACA,QAAA,GAAA;;AACA,QAAI,OAAA,CAAA,KAAJ,QAAA,EAA2B;AACzB,UAAIpE,OAAO,CAAX,MAAA,EAAoB;AAClBgE,QAAAA,GAAG,GAAGH,CAAC,CAADA,WAAAA,OAAoBpD,CAAC,CAA3BuD,WAA0BvD,EAA1BuD;AADF,OAAA,MAEO;AACLA,QAAAA,GAAG,GAAGH,CAAC,KAAPG,CAAAA;AACD;;AACD,WAAA,KAAA,CAAA,cAAA,EAAA,CAAA,EAAA,CAAA,EAAA,GAAA;AANF,KAAA,MAOO;AACLA,MAAAA,GAAG,GAAGH,CAAC,CAADA,KAAAA,CAANG,CAAMH,CAANG;AACA,WAAA,KAAA,CAAA,eAAA,EAAA,CAAA,EAAA,CAAA,EAAA,GAAA;AACD;;AAED,QAAI,CAAJ,GAAA,EAAU,OAAA,KAAA;AAvHmD,GAAA,CA0H/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AACA,MAAIC,EAAE,KAAFA,EAAAA,IAAaC,EAAE,KAAnB,EAAA,EAA4B;AAC1B;AACA;AACA,WAAA,IAAA;AAHF,GAAA,MAIO,IAAID,EAAE,KAAN,EAAA,EAAe;AACpB;AACA;AACA;AACA,WAAA,OAAA;AAJK,GAAA,MAKA,IAAIC,EAAE,KAAN,EAAA,EAAe;AACpB;AACA;AACA;AACA;AACA,QAAIK,YAAY,GAAIN,EAAE,KAAKE,EAAE,GAAV,CAACF,IAAmBF,IAAI,CAAJA,EAAI,CAAJA,KAAvC,EAAA;AACA,WAAA,YAAA;AArJ6D,GAAA,CAwJ/D;;;AACA,QAAM,IAAA,KAAA,CAAN,MAAM,CAAN;AAzJF5E,CAAAA,C,CA4JA;;;AACA,SAAA,YAAA,CAAA,CAAA,EAA0B;AACxB,SAAOwB,CAAC,CAADA,OAAAA,CAAAA,QAAAA,EAAP,IAAOA,CAAP;AACD;;AAED,SAAA,YAAA,CAAA,CAAA,EAA0B;AACxB,SAAOA,CAAC,CAADA,OAAAA,CAAAA,0BAAAA,EAAP,MAAOA,CAAP;AACD","sourcesContent":["module.exports = minimatch\nminimatch.Minimatch = Minimatch\n\nvar path = { sep: '/' }\ntry {\n  path = require('path')\n} catch (er) {}\n\nvar GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}\nvar expand = require('brace-expansion')\n\nvar plTypes = {\n  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},\n  '?': { open: '(?:', close: ')?' },\n  '+': { open: '(?:', close: ')+' },\n  '*': { open: '(?:', close: ')*' },\n  '@': { open: '(?:', close: ')' }\n}\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nvar qmark = '[^/]'\n\n// * => any number of characters\nvar star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nvar twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nvar twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'\n\n// characters that need to be escaped in RegExp.\nvar reSpecials = charSet('().*{}+?[]^$\\\\!')\n\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet (s) {\n  return s.split('').reduce(function (set, c) {\n    set[c] = true\n    return set\n  }, {})\n}\n\n// normalizes slashes.\nvar slashSplit = /\\/+/\n\nminimatch.filter = filter\nfunction filter (pattern, options) {\n  options = options || {}\n  return function (p, i, list) {\n    return minimatch(p, pattern, options)\n  }\n}\n\nfunction ext (a, b) {\n  a = a || {}\n  b = b || {}\n  var t = {}\n  Object.keys(b).forEach(function (k) {\n    t[k] = b[k]\n  })\n  Object.keys(a).forEach(function (k) {\n    t[k] = a[k]\n  })\n  return t\n}\n\nminimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return minimatch\n\n  var orig = minimatch\n\n  var m = function minimatch (p, pattern, options) {\n    return orig.minimatch(p, pattern, ext(def, options))\n  }\n\n  m.Minimatch = function Minimatch (pattern, options) {\n    return new orig.Minimatch(pattern, ext(def, options))\n  }\n\n  return m\n}\n\nMinimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return Minimatch\n  return minimatch.defaults(def).Minimatch\n}\n\nfunction minimatch (p, pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  // \"\" only matches \"\"\n  if (pattern.trim() === '') return p === ''\n\n  return new Minimatch(pattern, options).match(p)\n}\n\nfunction Minimatch (pattern, options) {\n  if (!(this instanceof Minimatch)) {\n    return new Minimatch(pattern, options)\n  }\n\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n  pattern = pattern.trim()\n\n  // windows support: need to use /, not \\\n  if (path.sep !== '/') {\n    pattern = pattern.split(path.sep).join('/')\n  }\n\n  this.options = options\n  this.set = []\n  this.pattern = pattern\n  this.regexp = null\n  this.negate = false\n  this.comment = false\n  this.empty = false\n\n  // make the set of regexps etc.\n  this.make()\n}\n\nMinimatch.prototype.debug = function () {}\n\nMinimatch.prototype.make = make\nfunction make () {\n  // don't do it more than once.\n  if (this._made) return\n\n  var pattern = this.pattern\n  var options = this.options\n\n  // empty patterns and comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    this.comment = true\n    return\n  }\n  if (!pattern) {\n    this.empty = true\n    return\n  }\n\n  // step 1: figure out negation, etc.\n  this.parseNegate()\n\n  // step 2: expand braces\n  var set = this.globSet = this.braceExpand()\n\n  if (options.debug) this.debug = console.error\n\n  this.debug(this.pattern, set)\n\n  // step 3: now we have a set, so turn each one into a series of path-portion\n  // matching patterns.\n  // These will be regexps, except in the case of \"**\", which is\n  // set to the GLOBSTAR object for globstar behavior,\n  // and will not contain any / characters\n  set = this.globParts = set.map(function (s) {\n    return s.split(slashSplit)\n  })\n\n  this.debug(this.pattern, set)\n\n  // glob --> regexps\n  set = set.map(function (s, si, set) {\n    return s.map(this.parse, this)\n  }, this)\n\n  this.debug(this.pattern, set)\n\n  // filter out everything that didn't compile properly.\n  set = set.filter(function (s) {\n    return s.indexOf(false) === -1\n  })\n\n  this.debug(this.pattern, set)\n\n  this.set = set\n}\n\nMinimatch.prototype.parseNegate = parseNegate\nfunction parseNegate () {\n  var pattern = this.pattern\n  var negate = false\n  var options = this.options\n  var negateOffset = 0\n\n  if (options.nonegate) return\n\n  for (var i = 0, l = pattern.length\n    ; i < l && pattern.charAt(i) === '!'\n    ; i++) {\n    negate = !negate\n    negateOffset++\n  }\n\n  if (negateOffset) this.pattern = pattern.substr(negateOffset)\n  this.negate = negate\n}\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function (pattern, options) {\n  return braceExpand(pattern, options)\n}\n\nMinimatch.prototype.braceExpand = braceExpand\n\nfunction braceExpand (pattern, options) {\n  if (!options) {\n    if (this instanceof Minimatch) {\n      options = this.options\n    } else {\n      options = {}\n    }\n  }\n\n  pattern = typeof pattern === 'undefined'\n    ? this.pattern : pattern\n\n  if (typeof pattern === 'undefined') {\n    throw new TypeError('undefined pattern')\n  }\n\n  if (options.nobrace ||\n    !pattern.match(/\\{.*\\}/)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse\nvar SUBPARSE = {}\nfunction parse (pattern, isSub) {\n  if (pattern.length > 1024 * 64) {\n    throw new TypeError('pattern is too long')\n  }\n\n  var options = this.options\n\n  // shortcuts\n  if (!options.noglobstar && pattern === '**') return GLOBSTAR\n  if (pattern === '') return ''\n\n  var re = ''\n  var hasMagic = !!options.nocase\n  var escaping = false\n  // ? => one single character\n  var patternListStack = []\n  var negativeLists = []\n  var stateChar\n  var inClass = false\n  var reClassStart = -1\n  var classStart = -1\n  // . and .. never match anything that doesn't start with .,\n  // even when options.dot is set.\n  var patternStart = pattern.charAt(0) === '.' ? '' // anything\n  // not (start or / followed by . or .. followed by / or end)\n  : options.dot ? '(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))'\n  : '(?!\\\\.)'\n  var self = this\n\n  function clearStateChar () {\n    if (stateChar) {\n      // we had some state-tracking character\n      // that wasn't consumed by this pass.\n      switch (stateChar) {\n        case '*':\n          re += star\n          hasMagic = true\n        break\n        case '?':\n          re += qmark\n          hasMagic = true\n        break\n        default:\n          re += '\\\\' + stateChar\n        break\n      }\n      self.debug('clearStateChar %j %j', stateChar, re)\n      stateChar = false\n    }\n  }\n\n  for (var i = 0, len = pattern.length, c\n    ; (i < len) && (c = pattern.charAt(i))\n    ; i++) {\n    this.debug('%s\\t%s %s %j', pattern, i, re, c)\n\n    // skip over any that are escaped.\n    if (escaping && reSpecials[c]) {\n      re += '\\\\' + c\n      escaping = false\n      continue\n    }\n\n    switch (c) {\n      case '/':\n        // completely not allowed, even escaped.\n        // Should already be path-split by now.\n        return false\n\n      case '\\\\':\n        clearStateChar()\n        escaping = true\n      continue\n\n      // the various stateChar values\n      // for the \"extglob\" stuff.\n      case '?':\n      case '*':\n      case '+':\n      case '@':\n      case '!':\n        this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c)\n\n        // all of those are literals inside a class, except that\n        // the glob [!a] means [^a] in regexp\n        if (inClass) {\n          this.debug('  in class')\n          if (c === '!' && i === classStart + 1) c = '^'\n          re += c\n          continue\n        }\n\n        // if we already have a stateChar, then it means\n        // that there was something like ** or +? in there.\n        // Handle the stateChar, then proceed with this one.\n        self.debug('call clearStateChar %j', stateChar)\n        clearStateChar()\n        stateChar = c\n        // if extglob is disabled, then +(asdf|foo) isn't a thing.\n        // just clear the statechar *now*, rather than even diving into\n        // the patternList stuff.\n        if (options.noext) clearStateChar()\n      continue\n\n      case '(':\n        if (inClass) {\n          re += '('\n          continue\n        }\n\n        if (!stateChar) {\n          re += '\\\\('\n          continue\n        }\n\n        patternListStack.push({\n          type: stateChar,\n          start: i - 1,\n          reStart: re.length,\n          open: plTypes[stateChar].open,\n          close: plTypes[stateChar].close\n        })\n        // negation is (?:(?!js)[^/]*)\n        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'\n        this.debug('plType %j %j', stateChar, re)\n        stateChar = false\n      continue\n\n      case ')':\n        if (inClass || !patternListStack.length) {\n          re += '\\\\)'\n          continue\n        }\n\n        clearStateChar()\n        hasMagic = true\n        var pl = patternListStack.pop()\n        // negation is (?:(?!js)[^/]*)\n        // The others are (?:<pattern>)<type>\n        re += pl.close\n        if (pl.type === '!') {\n          negativeLists.push(pl)\n        }\n        pl.reEnd = re.length\n      continue\n\n      case '|':\n        if (inClass || !patternListStack.length || escaping) {\n          re += '\\\\|'\n          escaping = false\n          continue\n        }\n\n        clearStateChar()\n        re += '|'\n      continue\n\n      // these are mostly the same in regexp and glob\n      case '[':\n        // swallow any state-tracking char before the [\n        clearStateChar()\n\n        if (inClass) {\n          re += '\\\\' + c\n          continue\n        }\n\n        inClass = true\n        classStart = i\n        reClassStart = re.length\n        re += c\n      continue\n\n      case ']':\n        //  a right bracket shall lose its special\n        //  meaning and represent itself in\n        //  a bracket expression if it occurs\n        //  first in the list.  -- POSIX.2 2.8.3.2\n        if (i === classStart + 1 || !inClass) {\n          re += '\\\\' + c\n          escaping = false\n          continue\n        }\n\n        // handle the case where we left a class open.\n        // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n        if (inClass) {\n          // split where the last [ was, make sure we don't have\n          // an invalid re. if so, re-walk the contents of the\n          // would-be class to re-translate any characters that\n          // were passed through as-is\n          // TODO: It would probably be faster to determine this\n          // without a try/catch and a new RegExp, but it's tricky\n          // to do safely.  For now, this is safe and works.\n          var cs = pattern.substring(classStart + 1, i)\n          try {\n            RegExp('[' + cs + ']')\n          } catch (er) {\n            // not a valid class!\n            var sp = this.parse(cs, SUBPARSE)\n            re = re.substr(0, reClassStart) + '\\\\[' + sp[0] + '\\\\]'\n            hasMagic = hasMagic || sp[1]\n            inClass = false\n            continue\n          }\n        }\n\n        // finish up the class.\n        hasMagic = true\n        inClass = false\n        re += c\n      continue\n\n      default:\n        // swallow any state char that wasn't consumed\n        clearStateChar()\n\n        if (escaping) {\n          // no need\n          escaping = false\n        } else if (reSpecials[c]\n          && !(c === '^' && inClass)) {\n          re += '\\\\'\n        }\n\n        re += c\n\n    } // switch\n  } // for\n\n  // handle the case where we left a class open.\n  // \"[abc\" is valid, equivalent to \"\\[abc\"\n  if (inClass) {\n    // split where the last [ was, and escape it\n    // this is a huge pita.  We now have to re-walk\n    // the contents of the would-be class to re-translate\n    // any characters that were passed through as-is\n    cs = pattern.substr(classStart + 1)\n    sp = this.parse(cs, SUBPARSE)\n    re = re.substr(0, reClassStart) + '\\\\[' + sp[0]\n    hasMagic = hasMagic || sp[1]\n  }\n\n  // handle the case where we had a +( thing at the *end*\n  // of the pattern.\n  // each pattern list stack adds 3 chars, and we need to go through\n  // and escape any | chars that were passed through as-is for the regexp.\n  // Go through and escape them, taking care not to double-escape any\n  // | chars that were already escaped.\n  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n    var tail = re.slice(pl.reStart + pl.open.length)\n    this.debug('setting tail', re, pl)\n    // maybe some even number of \\, then maybe 1 \\, followed by a |\n    tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, function (_, $1, $2) {\n      if (!$2) {\n        // the | isn't already escaped, so escape it.\n        $2 = '\\\\'\n      }\n\n      // need to escape all those slashes *again*, without escaping the\n      // one that we need for escaping the | character.  As it works out,\n      // escaping an even number of slashes can be done by simply repeating\n      // it exactly after itself.  That's why this trick works.\n      //\n      // I am sorry that you have to see this.\n      return $1 + $1 + $2 + '|'\n    })\n\n    this.debug('tail=%j\\n   %s', tail, tail, pl, re)\n    var t = pl.type === '*' ? star\n      : pl.type === '?' ? qmark\n      : '\\\\' + pl.type\n\n    hasMagic = true\n    re = re.slice(0, pl.reStart) + t + '\\\\(' + tail\n  }\n\n  // handle trailing things that only matter at the very end.\n  clearStateChar()\n  if (escaping) {\n    // trailing \\\\\n    re += '\\\\\\\\'\n  }\n\n  // only need to apply the nodot start if the re starts with\n  // something that could conceivably capture a dot\n  var addPatternStart = false\n  switch (re.charAt(0)) {\n    case '.':\n    case '[':\n    case '(': addPatternStart = true\n  }\n\n  // Hack to work around lack of negative lookbehind in JS\n  // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n  // like 'a.xyz.yz' doesn't match.  So, the first negative\n  // lookahead, has to look ALL the way ahead, to the end of\n  // the pattern.\n  for (var n = negativeLists.length - 1; n > -1; n--) {\n    var nl = negativeLists[n]\n\n    var nlBefore = re.slice(0, nl.reStart)\n    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)\n    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)\n    var nlAfter = re.slice(nl.reEnd)\n\n    nlLast += nlAfter\n\n    // Handle nested stuff like *(*.js|!(*.json)), where open parens\n    // mean that we should *not* include the ) in the bit that is considered\n    // \"after\" the negated section.\n    var openParensBefore = nlBefore.split('(').length - 1\n    var cleanAfter = nlAfter\n    for (i = 0; i < openParensBefore; i++) {\n      cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '')\n    }\n    nlAfter = cleanAfter\n\n    var dollar = ''\n    if (nlAfter === '' && isSub !== SUBPARSE) {\n      dollar = '$'\n    }\n    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast\n    re = newRe\n  }\n\n  // if the re is not \"\" at this point, then we need to make sure\n  // it doesn't match against an empty path part.\n  // Otherwise a/* will match a/, which it should not.\n  if (re !== '' && hasMagic) {\n    re = '(?=.)' + re\n  }\n\n  if (addPatternStart) {\n    re = patternStart + re\n  }\n\n  // parsing just a piece of a larger pattern.\n  if (isSub === SUBPARSE) {\n    return [re, hasMagic]\n  }\n\n  // skip the regexp for non-magical patterns\n  // unescape anything in it, though, so that it'll be\n  // an exact match against a file etc.\n  if (!hasMagic) {\n    return globUnescape(pattern)\n  }\n\n  var flags = options.nocase ? 'i' : ''\n  try {\n    var regExp = new RegExp('^' + re + '$', flags)\n  } catch (er) {\n    // If it was an invalid regular expression, then it can't match\n    // anything.  This trick looks for a character after the end of\n    // the string, which is of course impossible, except in multi-line\n    // mode, but it's not a /m regex.\n    return new RegExp('$.')\n  }\n\n  regExp._glob = pattern\n  regExp._src = re\n\n  return regExp\n}\n\nminimatch.makeRe = function (pattern, options) {\n  return new Minimatch(pattern, options || {}).makeRe()\n}\n\nMinimatch.prototype.makeRe = makeRe\nfunction makeRe () {\n  if (this.regexp || this.regexp === false) return this.regexp\n\n  // at this point, this.set is a 2d array of partial\n  // pattern strings, or \"**\".\n  //\n  // It's better to use .match().  This function shouldn't\n  // be used, really, but it's pretty convenient sometimes,\n  // when you just want to work with a regex.\n  var set = this.set\n\n  if (!set.length) {\n    this.regexp = false\n    return this.regexp\n  }\n  var options = this.options\n\n  var twoStar = options.noglobstar ? star\n    : options.dot ? twoStarDot\n    : twoStarNoDot\n  var flags = options.nocase ? 'i' : ''\n\n  var re = set.map(function (pattern) {\n    return pattern.map(function (p) {\n      return (p === GLOBSTAR) ? twoStar\n      : (typeof p === 'string') ? regExpEscape(p)\n      : p._src\n    }).join('\\\\\\/')\n  }).join('|')\n\n  // must match entire pattern\n  // ending in a * or ** will make it less strict.\n  re = '^(?:' + re + ')$'\n\n  // can match anything, as long as it's not this.\n  if (this.negate) re = '^(?!' + re + ').*$'\n\n  try {\n    this.regexp = new RegExp(re, flags)\n  } catch (ex) {\n    this.regexp = false\n  }\n  return this.regexp\n}\n\nminimatch.match = function (list, pattern, options) {\n  options = options || {}\n  var mm = new Minimatch(pattern, options)\n  list = list.filter(function (f) {\n    return mm.match(f)\n  })\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\n\nMinimatch.prototype.match = match\nfunction match (f, partial) {\n  this.debug('match', f, this.pattern)\n  // short-circuit in the case of busted things.\n  // comments, etc.\n  if (this.comment) return false\n  if (this.empty) return f === ''\n\n  if (f === '/' && partial) return true\n\n  var options = this.options\n\n  // windows: need to use /, not \\\n  if (path.sep !== '/') {\n    f = f.split(path.sep).join('/')\n  }\n\n  // treat the test path as a set of pathparts.\n  f = f.split(slashSplit)\n  this.debug(this.pattern, 'split', f)\n\n  // just ONE of the pattern sets in this.set needs to match\n  // in order for it to be valid.  If negating, then just one\n  // match means that we have failed.\n  // Either way, return on the first hit.\n\n  var set = this.set\n  this.debug(this.pattern, 'set', set)\n\n  // Find the basename of the path by looking for the last non-empty segment\n  var filename\n  var i\n  for (i = f.length - 1; i >= 0; i--) {\n    filename = f[i]\n    if (filename) break\n  }\n\n  for (i = 0; i < set.length; i++) {\n    var pattern = set[i]\n    var file = f\n    if (options.matchBase && pattern.length === 1) {\n      file = [filename]\n    }\n    var hit = this.matchOne(file, pattern, partial)\n    if (hit) {\n      if (options.flipNegate) return true\n      return !this.negate\n    }\n  }\n\n  // didn't get any hits.  this is success if it's a negative\n  // pattern, failure otherwise.\n  if (options.flipNegate) return false\n  return this.negate\n}\n\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\n  var options = this.options\n\n  this.debug('matchOne',\n    { 'this': this, file: file, pattern: pattern })\n\n  this.debug('matchOne', file.length, pattern.length)\n\n  for (var fi = 0,\n      pi = 0,\n      fl = file.length,\n      pl = pattern.length\n      ; (fi < fl) && (pi < pl)\n      ; fi++, pi++) {\n    this.debug('matchOne loop')\n    var p = pattern[pi]\n    var f = file[fi]\n\n    this.debug(pattern, p, f)\n\n    // should be impossible.\n    // some invalid regexp stuff in the set.\n    if (p === false) return false\n\n    if (p === GLOBSTAR) {\n      this.debug('GLOBSTAR', [pattern, p, f])\n\n      // \"**\"\n      // a/**/b/**/c would match the following:\n      // a/b/x/y/z/c\n      // a/x/y/z/b/c\n      // a/b/x/b/x/c\n      // a/b/c\n      // To do this, take the rest of the pattern after\n      // the **, and see if it would match the file remainder.\n      // If so, return success.\n      // If not, the ** \"swallows\" a segment, and try again.\n      // This is recursively awful.\n      //\n      // a/**/b/**/c matching a/b/x/y/z/c\n      // - a matches a\n      // - doublestar\n      //   - matchOne(b/x/y/z/c, b/**/c)\n      //     - b matches b\n      //     - doublestar\n      //       - matchOne(x/y/z/c, c) -> no\n      //       - matchOne(y/z/c, c) -> no\n      //       - matchOne(z/c, c) -> no\n      //       - matchOne(c, c) yes, hit\n      var fr = fi\n      var pr = pi + 1\n      if (pr === pl) {\n        this.debug('** at the end')\n        // a ** at the end will just swallow the rest.\n        // We have found a match.\n        // however, it will not swallow /.x, unless\n        // options.dot is set.\n        // . and .. are *never* matched by **, for explosively\n        // exponential reasons.\n        for (; fi < fl; fi++) {\n          if (file[fi] === '.' || file[fi] === '..' ||\n            (!options.dot && file[fi].charAt(0) === '.')) return false\n        }\n        return true\n      }\n\n      // ok, let's see if we can swallow whatever we can.\n      while (fr < fl) {\n        var swallowee = file[fr]\n\n        this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n        // XXX remove this slice.  Just pass the start index.\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n          this.debug('globstar found match!', fr, fl, swallowee)\n          // found a match.\n          return true\n        } else {\n          // can't swallow \".\" or \"..\" ever.\n          // can only swallow \".foo\" when explicitly asked.\n          if (swallowee === '.' || swallowee === '..' ||\n            (!options.dot && swallowee.charAt(0) === '.')) {\n            this.debug('dot detected!', file, fr, pattern, pr)\n            break\n          }\n\n          // ** swallows a segment, and continue.\n          this.debug('globstar swallow a segment, and continue')\n          fr++\n        }\n      }\n\n      // no match was found.\n      // However, in partial mode, we can't say this is necessarily over.\n      // If there's more *pattern* left, then\n      if (partial) {\n        // ran out of file\n        this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n        if (fr === fl) return true\n      }\n      return false\n    }\n\n    // something other than **\n    // non-magic patterns just have to match exactly\n    // patterns with magic have been turned into regexps.\n    var hit\n    if (typeof p === 'string') {\n      if (options.nocase) {\n        hit = f.toLowerCase() === p.toLowerCase()\n      } else {\n        hit = f === p\n      }\n      this.debug('string match', p, f, hit)\n    } else {\n      hit = f.match(p)\n      this.debug('pattern match', p, f, hit)\n    }\n\n    if (!hit) return false\n  }\n\n  // Note: ending in / means that we'll get a final \"\"\n  // at the end of the pattern.  This can only match a\n  // corresponding \"\" at the end of the file.\n  // If the file ends in /, then it can only match a\n  // a pattern that ends in /, unless the pattern just\n  // doesn't have any more for it. But, a/b/ should *not*\n  // match \"a/b/*\", even though \"\" matches against the\n  // [^/]*? pattern, except in partial mode, where it might\n  // simply not be reached yet.\n  // However, a/b/ should still satisfy a/*\n\n  // now either we fell off the end of the pattern, or we're done.\n  if (fi === fl && pi === pl) {\n    // ran out of pattern and filename at the same time.\n    // an exact hit!\n    return true\n  } else if (fi === fl) {\n    // ran out of file, but still had pattern left.\n    // this is ok if we're doing the match as part of\n    // a glob fs traversal.\n    return partial\n  } else if (pi === pl) {\n    // ran out of pattern, still have file left.\n    // this is only acceptable if we're on the very last\n    // empty segment of a file with a trailing slash.\n    // a/* should match a/b/\n    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')\n    return emptyFileEnd\n  }\n\n  // should be unreachable.\n  throw new Error('wtf?')\n}\n\n// replace stuff like \\* with *\nfunction globUnescape (s) {\n  return s.replace(/\\\\(.)/g, '$1')\n}\n\nfunction regExpEscape (s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n}\n"],"file":"minimatch.js"}