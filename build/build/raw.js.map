{"version":3,"sources":["../node_modules/asap/raw.js"],"names":["hasSetImmediate","module","queue","requestFlush","flushing","index","capacity","currentIndex","scan","newLength","rawAsap","parentDomain","process","domain","require","setImmediate"],"mappings":"AAAA;;AAEA,IAAA,MAAA,C,CAAY;;AACZ,IAAIA,eAAe,GAAG,OAAA,YAAA,KAAtB,UAAA,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAC,MAAM,CAANA,OAAAA,GAAAA,OAAAA;;AACA,SAAA,OAAA,CAAA,IAAA,EAAuB;AACnB,MAAI,CAACC,KAAK,CAAV,MAAA,EAAmB;AACfC,IAAAA,YAAY;AACZC,IAAAA,QAAQ,GAARA,IAAAA;AAHe,GAAA,CAKnB;;;AACAF,EAAAA,KAAK,CAACA,KAAK,CAAXA,MAAK,CAALA,GAAAA,IAAAA;AACH;;AAED,IAAIA,KAAK,GAAT,EAAA,C,CACA;AACA;;AACA,IAAIE,QAAQ,GAAZ,KAAA,C,CACA;AACA;AACA;;AACA,IAAIC,KAAK,GAAT,CAAA,C,CACA;AACA;AACA;;AACA,IAAIC,QAAQ,GAAZ,IAAA,C,CAEA;AACA;AACA;AACA;AACA;AACA;;AACA,SAAA,KAAA,GAAiB;AACb,SAAOD,KAAK,GAAGH,KAAK,CAApB,MAAA,EAA6B;AACzB,QAAIK,YAAY,GADS,KACzB,CADyB,CAEzB;AACA;;AACAF,IAAAA,KAAK,GAAGA,KAAK,GAAbA,CAAAA;AACAH,IAAAA,KAAK,CAALA,YAAK,CAALA,CALyB,IAKzBA,GALyB,CAMzB;AACA;AACA;AACA;AACA;;AACA,QAAIG,KAAK,GAAT,QAAA,EAAsB;AAClB;AACA;AACA,WAAK,IAAIG,IAAI,GAAR,CAAA,EAAcC,SAAS,GAAGP,KAAK,CAALA,MAAAA,GAA/B,KAAA,EAAqDM,IAAI,GAAzD,SAAA,EAAuEA,IAAvE,EAAA,EAA+E;AAC3EN,QAAAA,KAAK,CAALA,IAAK,CAALA,GAAcA,KAAK,CAACM,IAAI,GAAxBN,KAAmB,CAAnBA;AACH;;AACDA,MAAAA,KAAK,CAALA,MAAAA,IAAAA,KAAAA;AACAG,MAAAA,KAAK,GAALA,CAAAA;AACH;AACJ;;AACDH,EAAAA,KAAK,CAALA,MAAAA,GAAAA,CAAAA;AACAG,EAAAA,KAAK,GAALA,CAAAA;AACAD,EAAAA,QAAQ,GAARA,KAAAA;AACH;;AAEDM,OAAO,CAAPA,YAAAA,GAAAA,YAAAA;;AACA,SAAA,YAAA,GAAwB;AACpB;AACA;AACA;AACA,MAAIC,YAAY,GAAGC,OAAO,CAA1B,MAAA;;AACA,MAAA,YAAA,EAAkB;AACd,QAAI,CAAJ,MAAA,EAAa;AACT;AACA;AACAC,MAAAA,MAAM,GAAGC,OAAO,CAAhBD,QAAgB,CAAhBA;AACH;;AACDA,IAAAA,MAAM,CAANA,MAAAA,GAAgBD,OAAO,CAAPA,MAAAA,GAAhBC,IAAAA;AAXgB,GAAA,CAcpB;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAIT,QAAQ,IAAZ,eAAA,EAAiC;AAC7BW,IAAAA,YAAY,CAAZA,KAAY,CAAZA;AADJ,GAAA,MAEO;AACHH,IAAAA,OAAO,CAAPA,QAAAA,CAAAA,KAAAA;AACH;;AAED,MAAA,YAAA,EAAkB;AACdC,IAAAA,MAAM,CAANA,MAAAA,GAAgBD,OAAO,CAAPA,MAAAA,GAAhBC,YAAAA;AACH;AACJ","sourcesContent":["\"use strict\";\n\nvar domain; // The domain module is executed on demand\nvar hasSetImmediate = typeof setImmediate === \"function\";\n\n// Use the fastest means possible to execute a task in its own turn, with\n// priority over other events including network IO events in Node.js.\n//\n// An exception thrown by a task will permanently interrupt the processing of\n// subsequent tasks. The higher level `asap` function ensures that if an\n// exception is thrown by a task, that the task queue will continue flushing as\n// soon as possible, but if you use `rawAsap` directly, you are responsible to\n// either ensure that no exceptions are thrown from your task, or to manually\n// call `rawAsap.requestFlush` if an exception is thrown.\nmodule.exports = rawAsap;\nfunction rawAsap(task) {\n    if (!queue.length) {\n        requestFlush();\n        flushing = true;\n    }\n    // Avoids a function call\n    queue[queue.length] = task;\n}\n\nvar queue = [];\n// Once a flush has been requested, no further calls to `requestFlush` are\n// necessary until the next `flush` completes.\nvar flushing = false;\n// The position of the next task to execute in the task queue. This is\n// preserved between calls to `flush` so that it can be resumed if\n// a task throws an exception.\nvar index = 0;\n// If a task schedules additional tasks recursively, the task queue can grow\n// unbounded. To prevent memory excaustion, the task queue will periodically\n// truncate already-completed tasks.\nvar capacity = 1024;\n\n// The flush function processes all tasks that have been scheduled with\n// `rawAsap` unless and until one of those tasks throws an exception.\n// If a task throws an exception, `flush` ensures that its state will remain\n// consistent and will resume where it left off when called again.\n// However, `flush` does not make any arrangements to be called again if an\n// exception is thrown.\nfunction flush() {\n    while (index < queue.length) {\n        var currentIndex = index;\n        // Advance the index before calling the task. This ensures that we will\n        // begin flushing on the next task the task throws an error.\n        index = index + 1;\n        queue[currentIndex].call();\n        // Prevent leaking memory for long chains of recursive calls to `asap`.\n        // If we call `asap` within tasks scheduled by `asap`, the queue will\n        // grow, but to avoid an O(n) walk for every task we execute, we don't\n        // shift tasks off the queue after they have been executed.\n        // Instead, we periodically shift 1024 tasks off the queue.\n        if (index > capacity) {\n            // Manually shift all values starting at the index back to the\n            // beginning of the queue.\n            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {\n                queue[scan] = queue[scan + index];\n            }\n            queue.length -= index;\n            index = 0;\n        }\n    }\n    queue.length = 0;\n    index = 0;\n    flushing = false;\n}\n\nrawAsap.requestFlush = requestFlush;\nfunction requestFlush() {\n    // Ensure flushing is not bound to any domain.\n    // It is not sufficient to exit the domain, because domains exist on a stack.\n    // To execute code outside of any domain, the following dance is necessary.\n    var parentDomain = process.domain;\n    if (parentDomain) {\n        if (!domain) {\n            // Lazy execute the domain module.\n            // Only employed if the user elects to use domains.\n            domain = require(\"domain\");\n        }\n        domain.active = process.domain = null;\n    }\n\n    // `setImmediate` is slower that `process.nextTick`, but `process.nextTick`\n    // cannot handle recursion.\n    // `requestFlush` will only be called recursively from `asap.js`, to resume\n    // flushing after an error is thrown into a domain.\n    // Conveniently, `setImmediate` was introduced in the same version\n    // `process.nextTick` started throwing recursion errors.\n    if (flushing && hasSetImmediate) {\n        setImmediate(flush);\n    } else {\n        process.nextTick(flush);\n    }\n\n    if (parentDomain) {\n        domain.active = process.domain = parentDomain;\n    }\n}\n"],"file":"raw.js"}