{"version":3,"sources":["../node_modules/spdx-expression-parse/parse.js"],"names":["module","index","tokens","hasMore","t","token","operator","next","parseOperator","begin","string","license","node","exception","parseWith","left","expr","parseExpression","parseParenthesizedExpression","parseLicenseRef","parseLicense","nextParser","right","parseBinaryOp","conjunction","parseAnd","makeBinaryOpParser"],"mappings":"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","sourcesContent":["'use strict'\n\n// The ABNF grammar in the spec is totally ambiguous.\n//\n// This parser follows the operator precedence defined in the\n// `Order of Precedence and Parentheses` section.\n\nmodule.exports = function (tokens) {\n  var index = 0\n\n  function hasMore () {\n    return index < tokens.length\n  }\n\n  function token () {\n    return hasMore() ? tokens[index] : null\n  }\n\n  function next () {\n    if (!hasMore()) {\n      throw new Error()\n    }\n    index++\n  }\n\n  function parseOperator (operator) {\n    var t = token()\n    if (t && t.type === 'OPERATOR' && operator === t.string) {\n      next()\n      return t.string\n    }\n  }\n\n  function parseWith () {\n    if (parseOperator('WITH')) {\n      var t = token()\n      if (t && t.type === 'EXCEPTION') {\n        next()\n        return t.string\n      }\n      throw new Error('Expected exception after `WITH`')\n    }\n  }\n\n  function parseLicenseRef () {\n    // TODO: Actually, everything is concatenated into one string\n    // for backward-compatibility but it could be better to return\n    // a nice structure.\n    var begin = index\n    var string = ''\n    var t = token()\n    if (t.type === 'DOCUMENTREF') {\n      next()\n      string += 'DocumentRef-' + t.string + ':'\n      if (!parseOperator(':')) {\n        throw new Error('Expected `:` after `DocumentRef-...`')\n      }\n    }\n    t = token()\n    if (t.type === 'LICENSEREF') {\n      next()\n      string += 'LicenseRef-' + t.string\n      return {license: string}\n    }\n    index = begin\n  }\n\n  function parseLicense () {\n    var t = token()\n    if (t && t.type === 'LICENSE') {\n      next()\n      var node = {license: t.string}\n      if (parseOperator('+')) {\n        node.plus = true\n      }\n      var exception = parseWith()\n      if (exception) {\n        node.exception = exception\n      }\n      return node\n    }\n  }\n\n  function parseParenthesizedExpression () {\n    var left = parseOperator('(')\n    if (!left) {\n      return\n    }\n\n    var expr = parseExpression()\n\n    if (!parseOperator(')')) {\n      throw new Error('Expected `)`')\n    }\n\n    return expr\n  }\n\n  function parseAtom () {\n    return (\n      parseParenthesizedExpression() ||\n      parseLicenseRef() ||\n      parseLicense()\n    )\n  }\n\n  function makeBinaryOpParser (operator, nextParser) {\n    return function parseBinaryOp () {\n      var left = nextParser()\n      if (!left) {\n        return\n      }\n\n      if (!parseOperator(operator)) {\n        return left\n      }\n\n      var right = parseBinaryOp()\n      if (!right) {\n        throw new Error('Expected expression')\n      }\n      return {\n        left: left,\n        conjunction: operator.toLowerCase(),\n        right: right\n      }\n    }\n  }\n\n  var parseAnd = makeBinaryOpParser('AND', parseAtom)\n  var parseExpression = makeBinaryOpParser('OR', parseAnd)\n\n  var node = parseExpression()\n  if (!node || hasMore()) {\n    throw new Error('Syntax error')\n  }\n  return node\n}\n"],"file":"parse.js"}