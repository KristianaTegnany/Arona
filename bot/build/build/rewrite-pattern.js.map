{"version":3,"sources":["../node_modules/regexpu-core/rewrite-pattern.js"],"names":["generate","require","parse","regenerate","unicodeMatchProperty","unicodeMatchPropertyValue","iuMappings","ESCAPE_SETS","UNICODE_SET","BMP_SET","DOT_SET_UNICODE","getCharacterClassEscapeSet","getUnicodeDotSet","dotAll","getUnicodePropertyValueSet","path","value","property","handleLoneUnicodePropertyNameOrValue","category","getUnicodePropertyEscapeSet","parts","firstPart","set","$this","folded","caseFold","update","tree","config","wrap","Object","pattern","codePoint","processCharacterClass","characterClassItem","item","min","max","updateNamedReference","assertNoUnmatchedReferences","groups","unmatchedReferencesNames","processTerm","name","index","reference","term","rewritePattern","regjsparserFeatures","options","lookbehind","flags","supportDotAllFlag","regenerateOptions","unicode","module"],"mappings":"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","sourcesContent":["'use strict';\n\nconst generate = require('regjsgen').generate;\nconst parse = require('regjsparser').parse;\nconst regenerate = require('regenerate');\nconst unicodeMatchProperty = require('unicode-match-property-ecmascript');\nconst unicodeMatchPropertyValue = require('unicode-match-property-value-ecmascript');\nconst iuMappings = require('./data/iu-mappings.js');\nconst ESCAPE_SETS = require('./data/character-class-escape-sets.js');\n\n// Prepare a Regenerate set containing all code points, used for negative\n// character classes (if any).\nconst UNICODE_SET = regenerate().addRange(0x0, 0x10FFFF);\n// Without the `u` flag, the range stops at 0xFFFF.\n// https://mths.be/es6#sec-pattern-semantics\nconst BMP_SET = regenerate().addRange(0x0, 0xFFFF);\n\n// Prepare a Regenerate set containing all code points that are supposed to be\n// matched by `/./u`. https://mths.be/es6#sec-atom\nconst DOT_SET_UNICODE = UNICODE_SET.clone() // all Unicode code points\n\t.remove(\n\t\t// minus `LineTerminator`s (https://mths.be/es6#sec-line-terminators):\n\t\t0x000A, // Line Feed <LF>\n\t\t0x000D, // Carriage Return <CR>\n\t\t0x2028, // Line Separator <LS>\n\t\t0x2029  // Paragraph Separator <PS>\n\t);\n\nconst getCharacterClassEscapeSet = (character, unicode, ignoreCase) => {\n\tif (unicode) {\n\t\tif (ignoreCase) {\n\t\t\treturn ESCAPE_SETS.UNICODE_IGNORE_CASE.get(character);\n\t\t}\n\t\treturn ESCAPE_SETS.UNICODE.get(character);\n\t}\n\treturn ESCAPE_SETS.REGULAR.get(character);\n};\n\nconst getUnicodeDotSet = (dotAll) => {\n\treturn dotAll ? UNICODE_SET : DOT_SET_UNICODE;\n};\n\nconst getUnicodePropertyValueSet = (property, value) => {\n\tconst path = value ?\n\t\t`${ property }/${ value }` :\n\t\t`Binary_Property/${ property }`;\n\ttry {\n\t\treturn require(`regenerate-unicode-properties/${ path }.js`);\n\t} catch (exception) {\n\t\tthrow new Error(\n\t\t\t`Failed to recognize value \\`${ value }\\` for property ` +\n\t\t\t`\\`${ property }\\`.`\n\t\t);\n\t}\n};\n\nconst handleLoneUnicodePropertyNameOrValue = (value) => {\n\t// It could be a `General_Category` value or a binary property.\n\t// Note: `unicodeMatchPropertyValue` throws on invalid values.\n\ttry {\n\t\tconst property = 'General_Category';\n\t\tconst category = unicodeMatchPropertyValue(property, value);\n\t\treturn getUnicodePropertyValueSet(property, category);\n\t} catch (exception) {}\n\t// It’s not a `General_Category` value, so check if it’s a binary\n\t// property. Note: `unicodeMatchProperty` throws on invalid properties.\n\tconst property = unicodeMatchProperty(value);\n\treturn getUnicodePropertyValueSet(property);\n};\n\nconst getUnicodePropertyEscapeSet = (value, isNegative) => {\n\tconst parts = value.split('=');\n\tconst firstPart = parts[0];\n\tlet set;\n\tif (parts.length == 1) {\n\t\tset = handleLoneUnicodePropertyNameOrValue(firstPart);\n\t} else {\n\t\t// The pattern consists of two parts, i.e. `Property=Value`.\n\t\tconst property = unicodeMatchProperty(firstPart);\n\t\tconst value = unicodeMatchPropertyValue(property, parts[1]);\n\t\tset = getUnicodePropertyValueSet(property, value);\n\t}\n\tif (isNegative) {\n\t\treturn UNICODE_SET.clone().remove(set);\n\t}\n\treturn set.clone();\n};\n\n// Given a range of code points, add any case-folded code points in that range\n// to a set.\nregenerate.prototype.iuAddRange = function(min, max) {\n\tconst $this = this;\n\tdo {\n\t\tconst folded = caseFold(min);\n\t\tif (folded) {\n\t\t\t$this.add(folded);\n\t\t}\n\t} while (++min <= max);\n\treturn $this;\n};\n\nconst update = (item, pattern) => {\n\tlet tree = parse(pattern, config.useUnicodeFlag ? 'u' : '');\n\tswitch (tree.type) {\n\t\tcase 'characterClass':\n\t\tcase 'group':\n\t\tcase 'value':\n\t\t\t// No wrapping needed.\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// Wrap the pattern in a non-capturing group.\n\t\t\ttree = wrap(tree, pattern);\n\t}\n\tObject.assign(item, tree);\n};\n\nconst wrap = (tree, pattern) => {\n\t// Wrap the pattern in a non-capturing group.\n\treturn {\n\t\t'type': 'group',\n\t\t'behavior': 'ignore',\n\t\t'body': [tree],\n\t\t'raw': `(?:${ pattern })`\n\t};\n};\n\nconst caseFold = (codePoint) => {\n\treturn iuMappings.get(codePoint) || false;\n};\n\nconst processCharacterClass = (characterClassItem, regenerateOptions) => {\n\tlet set = regenerate();\n\tfor (const item of characterClassItem.body) {\n\t\tswitch (item.type) {\n\t\t\tcase 'value':\n\t\t\t\tset.add(item.codePoint);\n\t\t\t\tif (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {\n\t\t\t\t\tconst folded = caseFold(item.codePoint);\n\t\t\t\t\tif (folded) {\n\t\t\t\t\t\tset.add(folded);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'characterClassRange':\n\t\t\t\tconst min = item.min.codePoint;\n\t\t\t\tconst max = item.max.codePoint;\n\t\t\t\tset.addRange(min, max);\n\t\t\t\tif (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {\n\t\t\t\t\tset.iuAddRange(min, max);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'characterClassEscape':\n\t\t\t\tset.add(getCharacterClassEscapeSet(\n\t\t\t\t\titem.value,\n\t\t\t\t\tconfig.unicode,\n\t\t\t\t\tconfig.ignoreCase\n\t\t\t\t));\n\t\t\t\tbreak;\n\t\t\tcase 'unicodePropertyEscape':\n\t\t\t\tset.add(getUnicodePropertyEscapeSet(item.value, item.negative));\n\t\t\t\tbreak;\n\t\t\t// The `default` clause is only here as a safeguard; it should never be\n\t\t\t// reached. Code coverage tools should ignore it.\n\t\t\t/* istanbul ignore next */\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown term type: ${ item.type }`);\n\t\t}\n\t}\n\tif (characterClassItem.negative) {\n\t\tset = (config.unicode ? UNICODE_SET : BMP_SET).clone().remove(set);\n\t}\n\tupdate(characterClassItem, set.toString(regenerateOptions));\n\treturn characterClassItem;\n};\n\nconst updateNamedReference = (item, index) => {\n\tdelete item.name;\n\titem.matchIndex = index;\n};\n\nconst assertNoUnmatchedReferences = (groups) => {\n\tconst unmatchedReferencesNames = Object.keys(groups.unmatchedReferences);\n\tif (unmatchedReferencesNames.length > 0) {\n\t\tthrow new Error(`Unknown group names: ${unmatchedReferencesNames}`);\n\t}\n};\n\nconst processTerm = (item, regenerateOptions, groups) => {\n\tswitch (item.type) {\n\t\tcase 'dot':\n\t\t\tif (config.unicode) {\n\t\t\t\tupdate(\n\t\t\t\t\titem,\n\t\t\t\t\tgetUnicodeDotSet(config.dotAll).toString(regenerateOptions)\n\t\t\t\t);\n\t\t\t} else if (config.dotAll) {\n\t\t\t\t// TODO: consider changing this at the regenerate level.\n\t\t\t\tupdate(item, '[\\\\s\\\\S]');\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'characterClass':\n\t\t\titem = processCharacterClass(item, regenerateOptions);\n\t\t\tbreak;\n\t\tcase 'unicodePropertyEscape':\n\t\t\tupdate(\n\t\t\t\titem,\n\t\t\t\tgetUnicodePropertyEscapeSet(item.value, item.negative)\n\t\t\t\t\t.toString(regenerateOptions)\n\t\t\t);\n\t\t\tbreak;\n\t\tcase 'characterClassEscape':\n\t\t\tupdate(\n\t\t\t\titem,\n\t\t\t\tgetCharacterClassEscapeSet(\n\t\t\t\t\titem.value,\n\t\t\t\t\tconfig.unicode,\n\t\t\t\t\tconfig.ignoreCase\n\t\t\t\t).toString(regenerateOptions)\n\t\t\t);\n\t\t\tbreak;\n\t\tcase 'group':\n\t\t\tif (item.behavior == 'normal') {\n\t\t\t\tgroups.lastIndex++;\n\t\t\t}\n\t\t\tif (item.name) {\n\t\t\t\tconst name = item.name.value;\n\n\t\t\t\tif (groups.names[name]) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Multiple groups with the same name (${ name }) are not allowed.`\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst index = groups.lastIndex;\n\t\t\t\tdelete item.name;\n\n\t\t\t\tgroups.names[name] = index;\n\t\t\t\tif (groups.onNamedGroup) {\n\t\t\t\t\tgroups.onNamedGroup.call(null, name, index);\n\t\t\t\t}\n\n\t\t\t\tif (groups.unmatchedReferences[name]) {\n\t\t\t\t\tgroups.unmatchedReferences[name].forEach(reference => {\n\t\t\t\t\t\tupdateNamedReference(reference, index);\n\t\t\t\t\t});\n\t\t\t\t\tdelete groups.unmatchedReferences[name];\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* falls through */\n\t\tcase 'alternative':\n\t\tcase 'disjunction':\n\t\tcase 'quantifier':\n\t\t\titem.body = item.body.map(term => {\n\t\t\t\treturn processTerm(term, regenerateOptions, groups);\n\t\t\t});\n\t\t\tbreak;\n\t\tcase 'value':\n\t\t\tconst codePoint = item.codePoint;\n\t\t\tconst set = regenerate(codePoint);\n\t\t\tif (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {\n\t\t\t\tconst folded = caseFold(codePoint);\n\t\t\t\tif (folded) {\n\t\t\t\t\tset.add(folded);\n\t\t\t\t}\n\t\t\t}\n\t\t\tupdate(item, set.toString(regenerateOptions));\n\t\t\tbreak;\n\t\tcase 'reference':\n\t\t\tif (item.name) {\n\t\t\t\tconst name = item.name.value;\n\t\t\t\tconst index = groups.names[name];\n\t\t\t\tif (index) {\n\t\t\t\t\tupdateNamedReference(item, index);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (!groups.unmatchedReferences[name]) {\n\t\t\t\t\tgroups.unmatchedReferences[name] = [];\n\t\t\t\t}\n\t\t\t\t// Keep track of references used before the corresponding group.\n\t\t\t\tgroups.unmatchedReferences[name].push(item);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'anchor':\n\t\tcase 'empty':\n\t\tcase 'group':\n\t\t\t// Nothing to do here.\n\t\t\tbreak;\n\t\t// The `default` clause is only here as a safeguard; it should never be\n\t\t// reached. Code coverage tools should ignore it.\n\t\t/* istanbul ignore next */\n\t\tdefault:\n\t\t\tthrow new Error(`Unknown term type: ${ item.type }`);\n\t}\n\treturn item;\n};\n\nconst config = {\n\t'ignoreCase': false,\n\t'unicode': false,\n\t'dotAll': false,\n\t'useUnicodeFlag': false\n};\nconst rewritePattern = (pattern, flags, options) => {\n\tconst regjsparserFeatures = {\n\t\t'unicodePropertyEscape': options && options.unicodePropertyEscape,\n\t\t'namedGroups': options && options.namedGroup,\n\t\t'lookbehind': options && options.lookbehind\n\t};\n\tconfig.ignoreCase = flags && flags.includes('i');\n\tconfig.unicode = flags && flags.includes('u');\n\tconst supportDotAllFlag = options && options.dotAllFlag;\n\tconfig.dotAll = supportDotAllFlag && flags && flags.includes('s');\n\tconfig.useUnicodeFlag = options && options.useUnicodeFlag;\n\tconst regenerateOptions = {\n\t\t'hasUnicodeFlag': config.useUnicodeFlag,\n\t\t'bmpOnly': !config.unicode\n\t};\n\tconst groups = {\n\t\t'onNamedGroup': options && options.onNamedGroup,\n\t\t'lastIndex': 0,\n\t\t'names': Object.create(null), // { [name]: index }\n\t\t'unmatchedReferences': Object.create(null) // { [name]: Array<reference> }\n\t};\n\tconst tree = parse(pattern, flags, regjsparserFeatures);\n\t// Note: `processTerm` mutates `tree` and `groups`.\n\tprocessTerm(tree, regenerateOptions, groups);\n\tassertNoUnmatchedReferences(groups);\n\treturn generate(tree);\n};\n\nmodule.exports = rewritePattern;\n"],"file":"rewrite-pattern.js"}