{"version":3,"sources":["../node_modules/split-file/split-file.js"],"names":["Promise","require","fs","SplitFile","self","parts","stat","totalSize","splitSize","Math","lastSplitSize","partInfo","i","number","start","end","inputFiles","writer","encoding","reader","partFiles","info","maxPaddingCount","String","currentPad","unpaddedPartNumber","partNumber","partName","file","pipe","module"],"mappings":"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","sourcesContent":["/*!\n * Split File\n * MIT License\n * Tom Valk\n */\n\n/**\n *  Require Modules\n */\nvar Promise = require('bluebird');\nvar fs      = require('fs');\n\n/**\n * Split File module.\n */\nvar SplitFile = function () {};\n\n/**\n * Split file into number of parts\n * @param {string} file\n * @param {number} parts\n *\n * @returns {Promise}\n */\nSplitFile.prototype.splitFile = function(file, parts) {\n    var self = this;\n\n    // Validate parameters.\n    if (parts < 1) {\n        return Promise.reject(new Error(\"Parameter 'parts' is invalid, must contain an integer value.\"));\n    }\n\n    return Promise.promisify(fs.stat)(file).then(function (stat) {\n        if (! stat.isFile) {\n            return Promise.reject(new Error(\"Given file is not valid\"));\n        }\n        if (! stat.size) {\n            return Promise.reject(new Error(\"File is empty\"));\n        }\n\n        var totalSize = stat.size;\n        var splitSize = Math.floor(totalSize / parts);\n\n        // If size of the parts is 0 then you have more parts than bytes.\n        if(splitSize < 1) {\n            return Promise.reject(new Error(\"Too many parts, or file too small!\"));\n        }\n\n        // Get last split size, this is different from the others because it uses scrap value.\n        var lastSplitSize = splitSize + totalSize % parts;\n\n        // Capture the partinfo in here:\n        var partInfo = [];\n\n        // Iterate the parts\n        for (var i = 0; i < parts; i ++) {\n            partInfo[i] = {\n                number: i + 1,\n\n                // Set buffer read start position\n                start: i * splitSize,\n\n                // Set total ending position\n                end: (i * splitSize) + splitSize\n            };\n\n            if (i === (parts - 1)) {\n                partInfo[i].end = (i * splitSize) + lastSplitSize;\n            }\n        }\n\n        return self.__splitFile(file, partInfo);\n    });\n};\n\n/**\n * Split file into multiple parts based on max part size given\n * @param {string} file\n * @param {string} maxSize max part size in BYTES!\n * @returns {Promise}\n */\nSplitFile.prototype.splitFileBySize = function(file, maxSize) {\n    var self = this;\n\n    return Promise.promisify(fs.stat)(file).then(function (stat) {\n        if (! stat.isFile) {\n            return Promise.reject(new Error(\"Given file is not valid\"));\n        }\n        if (! stat.size) {\n            return Promise.reject(new Error(\"File is empty\"));\n        }\n\n        var totalSize = stat.size;\n\n        // Number of parts (exclusive last part!)\n        var parts = Math.ceil(totalSize / maxSize);\n        var splitSize = Math.round(maxSize);\n\n        // If size of the parts is 0 then you have more parts than bytes.\n        if(splitSize < 1) {\n            return Promise.reject(new Error(\"Too many parts, or file too small!\"));\n        }\n\n        // Capture the partinfo in here:\n        var partInfo = [];\n\n        // Iterate the parts\n        for (var i = 0; i < parts; i ++) {\n            partInfo[i] = {\n                number: i + 1,\n\n                // Set buffer read start position\n                start: i * splitSize,\n\n                // Set total ending position\n                end: (i * splitSize) + splitSize\n            };\n        }\n\n        // recalculate the size of the last chunk\n        partInfo[partInfo.length - 1].end = totalSize;\n\n        return self.__splitFile(file, partInfo);\n    });\n};\n\n/**\n * Merge input files to output file.\n * @param {string[]} inputFiles\n * @param {string} outputFile\n *\n * @returns {Promise}\n */\nSplitFile.prototype.mergeFiles = function(inputFiles, outputFile) {\n    // Validate parameters.\n    if (inputFiles.length <= 0) {\n        return Promise.reject(new Error(\"Make sure you input an array with files as first parameter!\"));\n    }\n\n    var writer = fs.createWriteStream(outputFile, {\n        encoding: null\n    });\n\n    return Promise.mapSeries(inputFiles, function (file) {\n        return new Promise(function (resolve, reject) {\n            var reader = fs.createReadStream(file, { encoding: null });\n            reader.pipe( writer, { end: false });\n            reader.on('error', reject);\n            reader.on('end', resolve);\n        });\n    }).then(function() {\n        writer.close();\n        return Promise.resolve(outputFile);\n    });\n};\n\n/**\n * Split the file, given by partinfos and filepath\n * @access private\n * @param {string} file\n * @param {object} partInfo\n *\n * @returns {Promise}\n */\nSplitFile.prototype.__splitFile = function (file, partInfo) {\n    // Now the magic. Read buffers with length..\n    var partFiles = [];\n\n    return Promise.mapSeries(partInfo, function (info) {\n        return new Promise(function (resolve, reject) {\n            // Open up a reader\n            var reader = fs.createReadStream(file, {\n                encoding: null,\n                start: info.start,\n                end: info.end - 1\n            });\n\n            // Part name (file name of part)\n            // get the max number of digits to generate for part number\n            // ex. if original file is split into 4 files, then it will be 1\n            // ex. if original file is split into 14 files, then it will be 2\n            // etc.\n            var maxPaddingCount = String(partInfo.length).length;\n            // initial part number\n            // ex. '0', '00', '000', etc.\n            var currentPad = '';\n            for (var i = 0; i < maxPaddingCount; i++) {\n                currentPad += '0';\n            }\n            // construct part number for current file part\n            // <file>.sf-part01\n            // ...\n            // <file>.sf-part14\n            var unpaddedPartNumber = '' + info.number;\n            var partNumber = currentPad.substring(0, currentPad.length - unpaddedPartNumber.length) + unpaddedPartNumber;\n            var partName = file + '.sf-part' + partNumber;\n\n            partFiles.push(partName);\n\n            // Open up writer\n            var writer = fs.createWriteStream(partName);\n\n            // Pipe reader to writer\n            var pipe = reader.pipe(writer);\n\n            pipe.on('error', reject);\n            pipe.on('finish', resolve);\n        });\n    }).then(function () {\n        return Promise.resolve(partFiles);\n    });;\n}\n\nmodule.exports = new SplitFile();\n"],"file":"split-file.js"}