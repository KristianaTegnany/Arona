{"version":3,"sources":["../node_modules/mime/mime.js"],"names":["path","require","fs","Object","Mime","exts","map","i","process","console","content","lines","fields","line","ext","type","mimeType","mime","lookup","module"],"mappings":"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","sourcesContent":["var path = require('path');\nvar fs = require('fs');\n\nfunction Mime() {\n  // Map of extension -> mime type\n  this.types = Object.create(null);\n\n  // Map of mime type -> extension\n  this.extensions = Object.create(null);\n}\n\n/**\n * Define mimetype -> extension mappings.  Each key is a mime-type that maps\n * to an array of extensions associated with the type.  The first extension is\n * used as the default extension for the type.\n *\n * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});\n *\n * @param map (Object) type definitions\n */\nMime.prototype.define = function (map) {\n  for (var type in map) {\n    var exts = map[type];\n    for (var i = 0; i < exts.length; i++) {\n      if (process.env.DEBUG_MIME && this.types[exts[i]]) {\n        console.warn((this._loading || \"define()\").replace(/.*\\//, ''), 'changes \"' + exts[i] + '\" extension type from ' +\n          this.types[exts[i]] + ' to ' + type);\n      }\n\n      this.types[exts[i]] = type;\n    }\n\n    // Default extension is the first one we encounter\n    if (!this.extensions[type]) {\n      this.extensions[type] = exts[0];\n    }\n  }\n};\n\n/**\n * Load an Apache2-style \".types\" file\n *\n * This may be called multiple times (it's expected).  Where files declare\n * overlapping types/extensions, the last file wins.\n *\n * @param file (String) path of file to load.\n */\nMime.prototype.load = function(file) {\n  this._loading = file;\n  // Read file and split into lines\n  var map = {},\n      content = fs.readFileSync(file, 'ascii'),\n      lines = content.split(/[\\r\\n]+/);\n\n  lines.forEach(function(line) {\n    // Clean up whitespace/comments, and split into fields\n    var fields = line.replace(/\\s*#.*|^\\s*|\\s*$/g, '').split(/\\s+/);\n    map[fields.shift()] = fields;\n  });\n\n  this.define(map);\n\n  this._loading = null;\n};\n\n/**\n * Lookup a mime type based on extension\n */\nMime.prototype.lookup = function(path, fallback) {\n  var ext = path.replace(/^.*[\\.\\/\\\\]/, '').toLowerCase();\n\n  return this.types[ext] || fallback || this.default_type;\n};\n\n/**\n * Return file extension associated with a mime type\n */\nMime.prototype.extension = function(mimeType) {\n  var type = mimeType.match(/^\\s*([^;\\s]*)(?:;|\\s|$)/)[1].toLowerCase();\n  return this.extensions[type];\n};\n\n// Default instance\nvar mime = new Mime();\n\n// Define built-in types\nmime.define(require('./types.json'));\n\n// Default type\nmime.default_type = mime.lookup('bin');\n\n//\n// Additional API specific to the default instance\n//\n\nmime.Mime = Mime;\n\n/**\n * Lookup a charset based on mime type.\n */\nmime.charsets = {\n  lookup: function(mimeType, fallback) {\n    // Assume text types are utf8\n    return (/^text\\/|^application\\/(javascript|json)/).test(mimeType) ? 'UTF-8' : fallback;\n  }\n};\n\nmodule.exports = mime;\n"],"file":"mime.js"}