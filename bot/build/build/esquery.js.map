{"version":3,"sources":["../node_modules/esquery/esquery.js"],"names":["estraverse","require","parser","isArray","Array","LEFT_SIDE","RIGHT_SIDE","keys","key","i","obj","path","node","ancestor","field","remainingPath","l","inPath","ancestry","selector","matches","collector","a","enter","parent","leave","p","getPath","sibling","adjacent","nthChild","length","listProp","startIndex","side","lowerBound","upperBound","k","idx","idxFn","results","subjects","altSubjects","m","match","parse","query","define","module","esqueryModule"],"mappings":"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","sourcesContent":["/* vim: set sw=4 sts=4 : */\n(function () {\n\n    var estraverse = require('estraverse');\n    var parser = require('./parser');\n\n    var isArray = Array.isArray || function isArray(array) {\n        return {}.toString.call(array) === '[object Array]';\n    };\n\n    var LEFT_SIDE = {};\n    var RIGHT_SIDE = {};\n\n    function esqueryModule() {\n\n        /**\n         * Get the value of a property which may be multiple levels down in the object.\n         */\n        function getPath(obj, key) {\n            var i, keys = key.split(\".\");\n            for (i = 0; i < keys.length; i++) {\n                if (obj == null) { return obj; }\n                obj = obj[keys[i]];\n            }\n            return obj;\n        }\n\n        /**\n         * Determine whether `node` can be reached by following `path`, starting at `ancestor`.\n         */\n        function inPath(node, ancestor, path) {\n            var field, remainingPath, i;\n            if (path.length === 0) { return node === ancestor; }\n            if (ancestor == null) { return false; }\n            field = ancestor[path[0]];\n            remainingPath = path.slice(1);\n            if (isArray(field)) {\n                for (i = 0, l = field.length; i < l; ++i) {\n                    if (inPath(node, field[i], remainingPath)) { return true; }\n                }\n                return false;\n            } else {\n                return inPath(node, field, remainingPath);\n            }\n        }\n\n        /**\n         * Given a `node` and its ancestors, determine if `node` is matched by `selector`.\n         */\n        function matches(node, selector, ancestry) {\n            var path, ancestor, i, l, p;\n            if (!selector) { return true; }\n            if (!node) { return false; }\n            if (!ancestry) { ancestry = []; }\n\n            switch(selector.type) {\n                case 'wildcard':\n                    return true;\n\n                case 'identifier':\n                    return selector.value.toLowerCase() === node.type.toLowerCase();\n\n                case 'field':\n                    path = selector.name.split('.');\n                    ancestor = ancestry[path.length - 1];\n                    return inPath(node, ancestor, path);\n\n                case 'matches':\n                    for (i = 0, l = selector.selectors.length; i < l; ++i) {\n                        if (matches(node, selector.selectors[i], ancestry)) { return true; }\n                    }\n                    return false;\n\n                case 'compound':\n                    for (i = 0, l = selector.selectors.length; i < l; ++i) {\n                        if (!matches(node, selector.selectors[i], ancestry)) { return false; }\n                    }\n                    return true;\n\n                case 'not':\n                    for (i = 0, l = selector.selectors.length; i < l; ++i) {\n                        if (matches(node, selector.selectors[i], ancestry)) { return false; }\n                    }\n                    return true;\n\n                case 'has':\n                    var a, collector = [];\n                    for (i = 0, l = selector.selectors.length; i < l; ++i) {\n                      a = [];\n                      estraverse.traverse(node, {\n                          enter: function (node, parent) {\n                              if (parent != null) { a.unshift(parent); }\n                              if (matches(node, selector.selectors[i], a)) {\n                                collector.push(node);\n                              }\n                          },\n                          leave: function () { a.shift(); }\n                      });\n                    }\n                    return collector.length !== 0;\n\n                case 'child':\n                    if (matches(node, selector.right, ancestry)) {\n                        return matches(ancestry[0], selector.left, ancestry.slice(1));\n                    }\n                    return false;\n\n                case 'descendant':\n                    if (matches(node, selector.right, ancestry)) {\n                        for (i = 0, l = ancestry.length; i < l; ++i) {\n                            if (matches(ancestry[i], selector.left, ancestry.slice(i + 1))) {\n                                return true;\n                            }\n                        }\n                    }\n                    return false;\n\n                case 'attribute':\n                    p = getPath(node, selector.name);\n                    switch (selector.operator) {\n                        case null:\n                        case void 0:\n                            return p != null;\n                        case '=':\n                            switch (selector.value.type) {\n                                case 'regexp': return typeof p === 'string' && selector.value.value.test(p);\n                                case 'literal': return '' + selector.value.value === '' + p;\n                                case 'type': return selector.value.value === typeof p;\n                            }\n                        case '!=':\n                            switch (selector.value.type) {\n                                case 'regexp': return !selector.value.value.test(p);\n                                case 'literal': return '' + selector.value.value !== '' + p;\n                                case 'type': return selector.value.value !== typeof p;\n                            }\n                        case '<=': return p <= selector.value.value;\n                        case '<': return p < selector.value.value;\n                        case '>': return p > selector.value.value;\n                        case '>=': return p >= selector.value.value;\n                    }\n\n                case 'sibling':\n                    return matches(node, selector.right, ancestry) &&\n                        sibling(node, selector.left, ancestry, LEFT_SIDE) ||\n                        selector.left.subject &&\n                        matches(node, selector.left, ancestry) &&\n                        sibling(node, selector.right, ancestry, RIGHT_SIDE);\n\n                case 'adjacent':\n                    return matches(node, selector.right, ancestry) &&\n                        adjacent(node, selector.left, ancestry, LEFT_SIDE) ||\n                        selector.right.subject &&\n                        matches(node, selector.left, ancestry) &&\n                        adjacent(node, selector.right, ancestry, RIGHT_SIDE);\n\n                case 'nth-child':\n                    return matches(node, selector.right, ancestry) &&\n                        nthChild(node, ancestry, function (length) {\n                            return selector.index.value - 1;\n                        });\n\n                case 'nth-last-child':\n                    return matches(node, selector.right, ancestry) &&\n                        nthChild(node, ancestry, function (length) {\n                            return length - selector.index.value;\n                        });\n\n                case 'class':\n                    if(!node.type) return false;\n                    switch(selector.name.toLowerCase()){\n                        case 'statement':\n                            if(node.type.slice(-9) === 'Statement') return true;\n                            // fallthrough: interface Declaration <: Statement { }\n                        case 'declaration':\n                            return node.type.slice(-11) === 'Declaration';\n                        case 'pattern':\n                            if(node.type.slice(-7) === 'Pattern') return true;\n                            // fallthrough: interface Expression <: Node, Pattern { }\n                        case 'expression':\n                            return node.type.slice(-10) === 'Expression' ||\n                                node.type.slice(-7) === 'Literal' ||\n                                (\n                                    node.type === 'Identifier' &&\n                                    (ancestry.length === 0 || ancestry[0].type !== 'MetaProperty')\n                                ) ||\n                                node.type === 'MetaProperty';\n                        case 'function':\n                            return node.type.slice(0, 8) === 'Function' ||\n                                node.type === 'ArrowFunctionExpression';\n                    }\n                    throw new Error('Unknown class name: ' + selector.name);\n            }\n\n            throw new Error('Unknown selector type: ' + selector.type);\n        }\n\n        /*\n         * Determines if the given node has a sibling that matches the given selector.\n         */\n        function sibling(node, selector, ancestry, side) {\n            var parent = ancestry[0], listProp, startIndex, keys, i, l, k, lowerBound, upperBound;\n            if (!parent) { return false; }\n            keys = estraverse.VisitorKeys[parent.type];\n            for (i = 0, l = keys.length; i < l; ++i) {\n                listProp = parent[keys[i]];\n                if (isArray(listProp)) {\n                    startIndex = listProp.indexOf(node);\n                    if (startIndex < 0) { continue; }\n                    if (side === LEFT_SIDE) {\n                      lowerBound = 0;\n                      upperBound = startIndex;\n                    } else {\n                      lowerBound = startIndex + 1;\n                      upperBound = listProp.length;\n                    }\n                    for (k = lowerBound; k < upperBound; ++k) {\n                        if (matches(listProp[k], selector, ancestry)) {\n                            return true;\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n\n        /*\n         * Determines if the given node has an asjacent sibling that matches the given selector.\n         */\n        function adjacent(node, selector, ancestry, side) {\n            var parent = ancestry[0], listProp, keys, i, l, idx;\n            if (!parent) { return false; }\n            keys = estraverse.VisitorKeys[parent.type];\n            for (i = 0, l = keys.length; i < l; ++i) {\n                listProp = parent[keys[i]];\n                if (isArray(listProp)) {\n                    idx = listProp.indexOf(node);\n                    if (idx < 0) { continue; }\n                    if (side === LEFT_SIDE && idx > 0 && matches(listProp[idx - 1], selector, ancestry)) {\n                        return true;\n                    }\n                    if (side === RIGHT_SIDE && idx < listProp.length - 1 && matches(listProp[idx + 1], selector, ancestry)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        /*\n         * Determines if the given node is the nth child, determined by idxFn, which is given the containing list's length.\n         */\n        function nthChild(node, ancestry, idxFn) {\n            var parent = ancestry[0], listProp, keys, i, l, idx;\n            if (!parent) { return false; }\n            keys = estraverse.VisitorKeys[parent.type];\n            for (i = 0, l = keys.length; i < l; ++i) {\n                listProp = parent[keys[i]];\n                if (isArray(listProp)) {\n                    idx = listProp.indexOf(node);\n                    if (idx >= 0 && idx === idxFn(listProp.length)) { return true; }\n                }\n            }\n            return false;\n        }\n\n        /*\n         * For each selector node marked as a subject, find the portion of the selector that the subject must match.\n         */\n        function subjects(selector, ancestor) {\n            var results, p;\n            if (selector == null || typeof selector != 'object') { return []; }\n            if (ancestor == null) { ancestor = selector; }\n            results = selector.subject ? [ancestor] : [];\n            for(p in selector) {\n                if(!{}.hasOwnProperty.call(selector, p)) { continue; }\n                [].push.apply(results, subjects(selector[p], p === 'left' ? selector[p] : ancestor));\n            }\n            return results;\n        }\n\n        /**\n         * From a JS AST and a selector AST, collect all JS AST nodes that match the selector.\n         */\n        function match(ast, selector) {\n            var ancestry = [], results = [], altSubjects, i, l, k, m;\n            if (!selector) { return results; }\n            altSubjects = subjects(selector);\n            estraverse.traverse(ast, {\n                enter: function (node, parent) {\n                    if (parent != null) { ancestry.unshift(parent); }\n                    if (matches(node, selector, ancestry)) {\n                        if (altSubjects.length) {\n                            for (i = 0, l = altSubjects.length; i < l; ++i) {\n                                if (matches(node, altSubjects[i], ancestry)) { results.push(node); }\n                                for (k = 0, m = ancestry.length; k < m; ++k) {\n                                    if (matches(ancestry[k], altSubjects[i], ancestry.slice(k + 1))) {\n                                        results.push(ancestry[k]);\n                                    }\n                                }\n                            }\n                        } else {\n                            results.push(node);\n                        }\n                    }\n                },\n                leave: function () { ancestry.shift(); }\n            });\n            return results;\n        }\n\n        /**\n         * Parse a selector string and return its AST.\n         */\n        function parse(selector) {\n            return parser.parse(selector);\n        }\n\n        /**\n         * Query the code AST using the selector string.\n         */\n        function query(ast, selector) {\n            return match(ast, parse(selector));\n        }\n\n        query.parse = parse;\n        query.match = match;\n        query.matches = matches;\n        return query.query = query;\n    }\n\n\n    if (typeof define === \"function\" && define.amd) {\n        define(esqueryModule);\n    } else if (typeof module !== 'undefined' && module.exports) {\n        module.exports = esqueryModule();\n    } else {\n        this.esquery = esqueryModule();\n    }\n\n})();\n"],"file":"esquery.js"}