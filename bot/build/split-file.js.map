{"version":3,"sources":["../node_modules/split-file/split-file.js"],"names":["Promise","require","fs","SplitFile","prototype","splitFile","file","parts","self","reject","Error","promisify","stat","then","isFile","size","totalSize","splitSize","Math","floor","lastSplitSize","partInfo","i","number","start","end","__splitFile","splitFileBySize","maxSize","ceil","round","length","mergeFiles","inputFiles","outputFile","writer","createWriteStream","encoding","mapSeries","resolve","reader","createReadStream","pipe","on","close","partFiles","info","maxPaddingCount","String","currentPad","unpaddedPartNumber","partNumber","substring","partName","push","module","exports"],"mappings":"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","sourcesContent":["/*!\n * Split File\n * MIT License\n * Tom Valk\n */\n\n/**\n *  Require Modules\n */\nvar Promise = require('bluebird');\nvar fs      = require('fs');\n\n/**\n * Split File module.\n */\nvar SplitFile = function () {};\n\n/**\n * Split file into number of parts\n * @param {string} file\n * @param {number} parts\n *\n * @returns {Promise}\n */\nSplitFile.prototype.splitFile = function(file, parts) {\n    var self = this;\n\n    // Validate parameters.\n    if (parts < 1) {\n        return Promise.reject(new Error(\"Parameter 'parts' is invalid, must contain an integer value.\"));\n    }\n\n    return Promise.promisify(fs.stat)(file).then(function (stat) {\n        if (! stat.isFile) {\n            return Promise.reject(new Error(\"Given file is not valid\"));\n        }\n        if (! stat.size) {\n            return Promise.reject(new Error(\"File is empty\"));\n        }\n\n        var totalSize = stat.size;\n        var splitSize = Math.floor(totalSize / parts);\n\n        // If size of the parts is 0 then you have more parts than bytes.\n        if(splitSize < 1) {\n            return Promise.reject(new Error(\"Too many parts, or file too small!\"));\n        }\n\n        // Get last split size, this is different from the others because it uses scrap value.\n        var lastSplitSize = splitSize + totalSize % parts;\n\n        // Capture the partinfo in here:\n        var partInfo = [];\n\n        // Iterate the parts\n        for (var i = 0; i < parts; i ++) {\n            partInfo[i] = {\n                number: i + 1,\n\n                // Set buffer read start position\n                start: i * splitSize,\n\n                // Set total ending position\n                end: (i * splitSize) + splitSize\n            };\n\n            if (i === (parts - 1)) {\n                partInfo[i].end = (i * splitSize) + lastSplitSize;\n            }\n        }\n\n        return self.__splitFile(file, partInfo);\n    });\n};\n\n/**\n * Split file into multiple parts based on max part size given\n * @param {string} file\n * @param {string} maxSize max part size in BYTES!\n * @returns {Promise}\n */\nSplitFile.prototype.splitFileBySize = function(file, maxSize) {\n    var self = this;\n\n    return Promise.promisify(fs.stat)(file).then(function (stat) {\n        if (! stat.isFile) {\n            return Promise.reject(new Error(\"Given file is not valid\"));\n        }\n        if (! stat.size) {\n            return Promise.reject(new Error(\"File is empty\"));\n        }\n\n        var totalSize = stat.size;\n\n        // Number of parts (exclusive last part!)\n        var parts = Math.ceil(totalSize / maxSize);\n        var splitSize = Math.round(maxSize);\n\n        // If size of the parts is 0 then you have more parts than bytes.\n        if(splitSize < 1) {\n            return Promise.reject(new Error(\"Too many parts, or file too small!\"));\n        }\n\n        // Capture the partinfo in here:\n        var partInfo = [];\n\n        // Iterate the parts\n        for (var i = 0; i < parts; i ++) {\n            partInfo[i] = {\n                number: i + 1,\n\n                // Set buffer read start position\n                start: i * splitSize,\n\n                // Set total ending position\n                end: (i * splitSize) + splitSize\n            };\n        }\n\n        // recalculate the size of the last chunk\n        partInfo[partInfo.length - 1].end = totalSize;\n\n        return self.__splitFile(file, partInfo);\n    });\n};\n\n/**\n * Merge input files to output file.\n * @param {string[]} inputFiles\n * @param {string} outputFile\n *\n * @returns {Promise}\n */\nSplitFile.prototype.mergeFiles = function(inputFiles, outputFile) {\n    // Validate parameters.\n    if (inputFiles.length <= 0) {\n        return Promise.reject(new Error(\"Make sure you input an array with files as first parameter!\"));\n    }\n\n    var writer = fs.createWriteStream(outputFile, {\n        encoding: null\n    });\n\n    return Promise.mapSeries(inputFiles, function (file) {\n        return new Promise(function (resolve, reject) {\n            var reader = fs.createReadStream(file, { encoding: null });\n            reader.pipe( writer, { end: false });\n            reader.on('error', reject);\n            reader.on('end', resolve);\n        });\n    }).then(function() {\n        writer.close();\n        return Promise.resolve(outputFile);\n    });\n};\n\n/**\n * Split the file, given by partinfos and filepath\n * @access private\n * @param {string} file\n * @param {object} partInfo\n *\n * @returns {Promise}\n */\nSplitFile.prototype.__splitFile = function (file, partInfo) {\n    // Now the magic. Read buffers with length..\n    var partFiles = [];\n\n    return Promise.mapSeries(partInfo, function (info) {\n        return new Promise(function (resolve, reject) {\n            // Open up a reader\n            var reader = fs.createReadStream(file, {\n                encoding: null,\n                start: info.start,\n                end: info.end - 1\n            });\n\n            // Part name (file name of part)\n            // get the max number of digits to generate for part number\n            // ex. if original file is split into 4 files, then it will be 1\n            // ex. if original file is split into 14 files, then it will be 2\n            // etc.\n            var maxPaddingCount = String(partInfo.length).length;\n            // initial part number\n            // ex. '0', '00', '000', etc.\n            var currentPad = '';\n            for (var i = 0; i < maxPaddingCount; i++) {\n                currentPad += '0';\n            }\n            // construct part number for current file part\n            // <file>.sf-part01\n            // ...\n            // <file>.sf-part14\n            var unpaddedPartNumber = '' + info.number;\n            var partNumber = currentPad.substring(0, currentPad.length - unpaddedPartNumber.length) + unpaddedPartNumber;\n            var partName = file + '.sf-part' + partNumber;\n\n            partFiles.push(partName);\n\n            // Open up writer\n            var writer = fs.createWriteStream(partName);\n\n            // Pipe reader to writer\n            var pipe = reader.pipe(writer);\n\n            pipe.on('error', reject);\n            pipe.on('finish', resolve);\n        });\n    }).then(function () {\n        return Promise.resolve(partFiles);\n    });;\n}\n\nmodule.exports = new SplitFile();\n"],"file":"split-file.js"}